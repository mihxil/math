// DO NOT EDIT THIS FILE, IT IS GENERATED!! (source: README-source.adoc)
= Algebraic interfaces for Java
Michiel Meeuwissen <michiel.meeuwissen@gmail.com>
:book:
:sectnums:
:toc: left
:toclevels: 3
:stem:
:nofooter:
:source-highlighter: coderay
:multipage-level: 1
:docinfo: private
:myleveloffset: 2


:gh: https://github.com/mihxil/math/

image:{gh}actions/workflows/build.yml/badge.svg?[Build Status,link={gh}actions/workflows/build.yml]
image:https://codecov.io/gh/mihxil/math/branch/main/graph/badge.svg[codecov,link=https://codecov.io/gh/mihxil/math]
//image:https://img.shields.io/nexus/s/https/oss.sonatype.org/org.meeuw.math/mihxil-math.svg[snapshots,link=https://oss.sonatype.org/content/repositories/snapshots/org/meeuw/math/]
image:https://img.shields.io/maven-central/v/org.meeuw.math/mihxil-math.svg[Maven Central,link=https://central.sonatype.com/search?q=g%3Aorg.meeuw.math]
image:https://www.javadoc.io/badge/org.meeuw.math/mihxil-math.svg?color=blue[javadoc,link=https://www.javadoc.io/doc/org.meeuw.math]


[NOTE]
====
See link:https://mihxil.github.io/math/[this file in html] for proper display of the (few) mathematical equations and MP4-movies. This has some working demo's, but those are beter elaborated in this link:https://mihxil.github.io/math/DEMO.html[dedicated page for that]. This uses webassembly to run java in your browser.
====

:leveloffset: 1

= quickstart

The core of this project is quite abstract and more or less theoretical. But here are some handy things in this.

NOTE: examples in this section use java 25's link:https://openjdk.org/jeps/512[compact source files]

== statistics

Take dependency on link:https://central.sonatype.com/artifact/org.meeuw.math/mihxil-statistics[`org.meeuw.math:mihxil-statistics`] and use things like

[source, java]
----
import module org.meeuw.math.statistics;

void main() {
    var windowed = WindowedStatisticalLong
        .builder()
        .bucketDuration(Duration.ofMinutes(5))
        .build();

    windowed.accept(100, 101, 102);

    IO.println(windowed.get()); // prints 101.0 ± 0.8

}

----

== date parsing
Take dependency on link:https://central.sonatype.com/artifact/org.meeuw/mihxil-time[`org.meeuw:mihxil-time`] and use

[source, java]
----
import module org.meeuw.time;

void main() {
    var dynamicDateTime = new DynamicDateTime();
    IO.println(
        // Prints the date 5 days from now
        dynamicDateTime.apply("today + 5 days").toLocalDate()
    );
}

----

== algebraic structures
A lot of 'algebraic structures' are implemented in link:https://central.sonatype.com/artifact/org.meeuw.math/mihxil-algebra[`org.meeuw.math:mihxil-algebra`].

E.g. if you want to use the quaternions implementation:
[source, java]
----
import static org.meeuw.math.abstractalgebra.quaternions.Quaternions.H_Q;

void main() {
    // Quaternions over rational numbers
    var a = H_Q.fromString("1 + 2i + 3j + 4k");
    var b = H_Q.fromString("2 - 2i + 3j - 4k");
    IO.println(a.times(b)); // prints 13 - 22i + 9j + 16k
}

----

== theories

quick explanation of theories.

== configuration





:leveloffset!:

:leveloffset: 1

= math
:gh: https://github.com/mihxil/math/
:ghraw: https://raw.githubusercontent.com/mihxil/math/main/
:ghblob: {gh}blob/main/
:ghm: {ghblob}mihxil-math/src/main/java/org/meeuw/math/
:ght: {ghblob}mihxil-theories/src/main/java/
:docs: {ghraw}docs
:videooptions: width=400,height=400,opts=loop,nocontrols,preload=none




image:https://img.shields.io/maven-central/v/org.meeuw.math/mihxil-math.svg[Maven Central,link=https://search.maven.org/artifact/org.meeuw.math/mihxil-math]
image:https://javadoc.io/badge/org.meeuw.math/mihxil-math.svg?color=blue[javadoc,link=https://www.javadoc.io/doc/org.meeuw.math/mihxil-math]

The core dependency of the modules in the project. It provides the scaffolding for:

- Abstract algebra's to ensure a common interface for basic operations. Java does not provide operator overloading. This provides an alternative. Implementations of these interfaces can be 'property-based' tested, to make sure that the implementation indeed adheres to the contracts.
- An 'uncertain number' interface, plus an implementation of an algebraic field of uncertain numbers.
- A Service Provider Interface for formatting the elements of abstract algebras.  This core module only provides an implementation to format  uncertain numbers, using proper rounding and scientific notation.

== Abstract Algebras

The idea is that every 'abstract algebra' consists of the implementation of two interfaces

. One of the extensions of  link:{ghm}abstractalgebra/AlgebraicElement.java[`org.meeuw.math.abstractalgebra.AlgebraicElement`] defines the properties of all elements of the algebra. It also should implement the actual operations like multiplication and addition.

. One of the corresponding extensions of link:{ghm}abstractalgebra/AlgebraicStructure.java[`org.meeuw.math.abstractalgebra.AlgebraicStructure`], e.g.  link:{ghm}abstractalgebra/Field.java[`org.meeuw.math.abstractalgebra.Field`],  defines properties of the structure itself, and it also serves as a container for utility method for its elements. E.g. if the structure is powerful enough to implement determinants of matrices of its elements, it does so (and more advanced structures, may do it more sophisticatedly. E.g. `Ring` implements `determinant` without using division, but in `DivisionRing` the implementation is optimized with use of that operation)

The terminology which is adopted is this:

|===
|Algebraic operation  | operator | operator name | static operator name | result name | argument name | defined in

7+^|binary operators
|operation| `*` | operate | operate | operation | operand |  link:{ghm}abstractalgebra/MagmaElement.java[`MagmaElement`]
|addition | `+` | plus | add | sum | summand
| link:{ghm}abstractalgebra/AdditiveSemiGroupElement.java[`AdditiveSemiGroupElement`]
|subtraction | `-` | minus | subtract | difference | subtrahend | link:{ghm}abstractalgebra/AdditiveGroupElement.java[`AdditiveGroupElement`]
|multiplication |  `⋅`  | times | multiply | product | multiplier | link:{ghm}abstractalgebra/MultiplicativeSemiGroupElement.java[`MultiplicativeSemiGroupElement`]
|division | `/` | dividedBy | divide | quotient |  divisor | link:{ghm}abstractalgebra/MultiplicativeGroupElement.java[`MultiplicativeGroupElement`]
|exponentiation | `^` | pow | pow | power| exponent| link:{ghm}abstractalgebra/CompleteFieldElement.java[`CompleteFieldElement`]
|metric or distance| `d()` | distanceTo | metric | distance|| link:{ghm}abstractalgebra/MetricSpaceElement.java[`MetricSpaceElement`]

7+^|unary operators
|negation      | `-` | negation | negate | negation|| link:{ghm}abstractalgebra/AdditiveGroupElement.java[`AdditiveGroupElement`]
|reciprocation | `1/` |  reciprocal | | reciprocal|| link:{ghm}abstractalgebra/MultiplicativeGroupElement.java[`MultiplicativeGroupElement`]
|square root | `√` | sqrt | sqrt
 | square root| radicand | link:{ghm}abstractalgebra/CompleteFieldElement.java[`CompleteFieldElement`]
|sine | `sin()`| sin | sin | sine| angle | link:{ghm}abstractalgebra/CompleteFieldElement.java[`CompleteFieldElement`]
|cosine | `cos()` | cos | cos | cosine| angle | link:{ghm}abstractalgebra/CompleteFieldElement.java[`CompleteFieldElement`]
|absolute value, distance to zero|  \|\|  | abs| abs| absolute value|| link:{ghm}abstractalgebra/MetricSpaceElement.java[`MetricSpaceElement`]
|identify| + |  self |  |  |   | link:{ghm}abstractalgebra/AlgebraicElement.java[`AlgebraicElement`]


7+^|comparison operators
|equals      | `=` | equals | equals | equality| object| `java.lang.Object`
|loosely equals | `≈` | eq | equals | equality| other element| link:{ghm}abstractalgebra/AlgebraicElement.java[`AlgebraicElement`]

7+^| integer operators
| root | `^n^√x` | root | root | n-th root | base | link:{ghm}abstractalgebra/CompleteFieldElement.java[`CompleteFieldElement`]
| power | `x^n^` |  |  | n-th power  | exponent |  link:{ghm}abstractalgebra/CompleteFieldElement.java[`CompleteFieldElement`]
| tetration | `x↑↑n` `^n^x` |   |   |  | height | link:{ghm}abstractalgebra/CompleteFieldElement.java[`CompleteFieldElement`]

|===

The methods on the elements take the name of the corresponding operator. So e.g.:

[source,java]
----
RationalNumber a, b, c;
c = a.times(b);
----

These methods always take the value of the element itself plus zero parameters (for the unary operators) or one parameter (for the binary operators), and create a new value from the same algebra.

Alternative terminology, like e.g. 'add' for addition would have been possible, but it was chosen to use those verbs when the operation is e.g. implemented statically (`E add(e1, e2)`) or are modifying the element itself.

Most implementations are strictly read-only, but at least all algebraic operations themselves should be without side effects on the algebraic element itself.

=== Algebraic structure

Every algebraic element object has a reference to (the same)  instance of this structure. The structure itself defines e.g. the 'cardinality'.

NOTE: If the cardinality is 'countable' (< ℵ~1~), the structure can also implement  link:{ghm}abstractalgebra/Streamable.java[`Streamable`] to actually produce all possible elements.

The algebraic structure also contains methods to obtain 'special elements' like the identity elements for multiplication and addition (_one_ and _zero_).

image::{docs}/algebras.svg[title="The defined algebraic structures, with indication of the operators (and whether they are commutative), special elements, and example implementations.", link="{docs}/algebras.svg"]

=== Numbers

Some algebraic elements are like real numbers. There are several interfaces dedicated to formalising properties of that.

|===
| class/interface  | description

| link:{ghm}numbers/Scalar.java[`Scalar`] |
A generic interface that defines the methods to convert to java (primitive) number objects. Like `doubleValue()` and `intValue()`. It extends a few interfaces for some properties which can be applied to other structures to, like `Sizeable` and `SignedNumber`.

| link:{ghm}abstractalgebra/ScalarFieldElement.java[`ScalarFieldElement`] |
A `Scalar` that is also a `FieldElement`. So this is the link from number to algebra. Well-behaved field elements that also behave as a 'Number' may implement `ScalarFieldElement`

| link:{ghm}abstractalgebra/CompleteFieldElement.java[`CompleteFieldElement`] |
Even more similar to the everyday concept of a number are elements of an algebraic field that is 'complete'.  This in some way means that is has 'no gaps', but essentially boils down to the fact that operations like taking square roots and trigonometric function are possible within the algebra.

| link:{ghm}numbers/NumberOperations.java[`NumberOperations`]
link:{ghm}numbers/UncertaintyNumberOperations.java[`UncertaintyNumberOperations`]
|
Number like structures are backed by existing classes  `BigDecimal` and `Double`. These lack a common interface. Implementations of this class wrap these things with a common interface to all needed operations.
. E.g. it may use `BigDecimalMath` for `BigDecimal` and `Math#log` for `Double`.

The specialization `UncertaintyNumberOperations` adds the logic for propagation of uncertainties.
|===


=== Numbers and propagation of uncertainties

Most real numbers cannot be represented exactly. It may be of interest to keep track of the uncertainty in the value, and try to propagate those uncertainties sensibly when performing operations on them.

The 'physics' module will add to this that these kinds of uncertainties may originate not only in the finite nature of representing them, but also in the limitations of actually _measuring_ things.

The 'statistics' module introduces uncertain numbers where the uncertainty is defined as the standard deviation in a collected set of values. These numbers are examples of elements that are actually stateful, because new values can be added to the set. This should not actually change the _value_ represented by  the object though, only decrease its _uncertainty_. On performing operations on these kinds of objects you would receive unmodifiable stateless objects with frozen value and uncertainty.

It is not always absolutely defined how propagations must happen. Some interpretation may be needed sometimes. The choices made are currently collected in `UncertaintyNumberOperations'.  This is not currently pluggable or configurable, but it may well be.

|===
| operation | formula | current uncertainty propagation algorithm

| summation | latexmath:[a ± Δa + b ± Δb] | latexmath:[\sqrt{Δa^2 + Δb^2}]
| multiplication | latexmath:[a ± Δa \cdot b ± Δb] |
 latexmath:[\mid a \cdot b \mid \cdot \sqrt{\left(\frac{Δa}{\mid a \mid + Δa }\right)^2 + \left(\frac{Δb}{\mid b \mid + Δb }\right)^2}]
| exponentiation |
 latexmath:[\left(a ± Δa\right) ^ {e ± Δe}]
|
 latexmath:[\mid a ^ e\mid \cdot
\sqrt{
  \left(\frac{e \cdot Δa}{a}\right)^2 +
  \left(\ln(a) \cdot Δe\right)^2
}]

| sin/cos | latexmath:[\sin(\alpha \pm \Delta\alpha)] | latexmath:[\Delta\alpha]| | |
|===

==== Zero

Sometimes the value with uncertainty is exactly _zero_, so fractional uncertainty leads to division by zero exceptions. Therefore, for now fractional uncertainty is implemented like latexmath:[ \frac{Δa}{|a| +  Δa}] (rather then latexmath:[ \frac{Δa}{|a|}]), where the denominator can never become zero because the uncertainty is strictly bigger than zero.


=== Testing

In link:{gh}/mihxil-theories[mihxil-theories] for every algebraic structure interface there are 'theory' interfaces using link:https://jqwik.net/[jqwik]. Tests for actual implementations implement these interfaces and provide the code to supply a bunch of example link:{ght}test/ElementTheory.java#L20[`elements`].

Default methods then test whether all theoretical possibilities and limitations of the algebraic structure are indeed working.

=== Implementation of `equals`/`hashCode` and `eq`

When a value has uncertainty, then `equals` could consider it. So objects may e.g. have different `toString` representation but still be equal, because the difference is considered smaller than the uncertainty, and so can be considered equal.

This is abstracted using a `ConfidenceInterval` concept.


In this case the `hashCode` must be a fixed value, because otherwise we can't guarantee that equal values have equal hashCode.

This implies that it's a bad idea to use uncertain values as hash keys.

==== Transitivity of equality

Java - and also mathematics - normally requires that the equality operator ('`=`') is transitive.

For several of the objects (the `Uncertain` ones) this represents a problem, because on one hand it is expected that things like `(x^-1^)^-1^ = x`, and on the other hand transitivity of equals is desired (`x = y ∧ y = z → x = z`).

Therefore, the elements of algebra's have several methods for equality

==== eq

This is the most used equality in algebras. For uncertain valued algebras this _may not be transitive_,  because the uncertainty is considered.

 E.g. `10 ± 5 eq 14 ± 1` and `18 ± 5 eq 14 ± 1`, but `! (10 ± 5 eq  18 ± 5 )`.

For non-uncertain values, `eq` would behave the same as `equals`, the only difference being that its argument is not `Object`.

==== strictlyEquals

If the value is `Uncertain` then it also implements a method `strictlyEquals` which just compares the value without considering uncertainty. This guarantees transitivity, but e.g. reciprocity of inverse operator may not be, since e.g. because of rounding errors  ``(x^-1^)^-1^ !strictlyEquals  x`,


==== equals

Java's `equals` method is implemented with `strictlyEquals` or with `eq` if the value is not uncertain (`strictlyEquals` is not available, and it would make no difference).

Via the `CompareConfiguration` configuration aspect, it can be configured though, that `equals` is like `eq`.

[source, java]
----
 withAspect(CompareConfiguration.class, compareConfiguration -> compareConfiguration.withEqualsIsStrict(false), () -> {
     /// here equals behave like eq
 }
----
This common case can also be accessed more concisely:
[source, java]
----
CompareConfiguration.withLooseEquals(() -> {
    // code here
});
----

== Formatting and configuration

A service loader is provided for implementations of `AlgebraicElementFormatProvider` which can create instances of `java.text.Format` which in turn can be used to convert algebraic elements to a string. `#toString` can be based on it.

The formatters have access to a (thread local) configuration object (see <<configuration_service>>). Like this a consistent way is available to configure how e.g., uncertainties must be represented. Currently, this configuration object can only be filled by code. The base configuration object in itself is empty, but the available `AlgebraicElementFormatProvider`s  communicate the 'configuration aspects' which it can use.

The service giving access to the format-providers is `FormatService`. This is a collection of static functions.



=== unicode

Formatting normally happens using Unicode if possible. So if it is common in mathematics or physics to use superscripts, subscripts, greek letters or other special symbols, then this will be done as good as possible using just Unicode characters and modifiers.

== Utilities

To implement several aspects of the groups there are provided some utility class. We describe here a few which might be of particular interest.

=== Cartesian product of streams

All countable, `Streamable` algebras need to implement a stream providing _all_ elements. This is not always trivial. It may require producing all combinations of all elements of two or more underlying streams of objects.

For finite streams, this is more or less trivial. For _infinite_ streams, this is a bit more interesting.

==== Generic

link:{ghm}streams/StreamUtils.java[`StreamUtils`] provides several utilities related to streams.


The most generic implementation requires for every axis a supplier for the stream, which will be used every time the first value of the stream is needed again.

This implementation then only advances streams, and needs no state otherwise.


NOTE: Some videos are available to show this, which are not working here. Visit this page on link:https://mihxil.github.io/math/#_cartesian_product_of_streams[github pages]


.All combinations of 2 streams of positive integers.
video::{docs}/positive-plane.mp4[{videooptions}]

.All combinations of 3 streams of positive integers.
video::C0uaFTHoMVQ[youtube,{videooptions}]

==== Diagonals

The 2-dimensional plane of integers traditionally can be filled by tracking _diagonals_.  `StreamUtils` provides an implementation of that too. It is harder to generalize this to more dimensions, and also it requires that streams can be tracked reversely.


.All combinations of 2 streams of positive integers (diagonals)
video::{docs}/diagonals-positive-plane.mp4[{videooptions}]

:leveloffset!:

:leveloffset: 1

= time
:toc:

image:https://img.shields.io/maven-central/v/org.meeuw/mihxil-time.svg[Maven Central,link=https://search.maven.org/artifact/org.meeuw/mihxil-time]
image:https://www.javadoc.io/badge/org.meeuw/mihxil-time.svg?color=blue[javadoc,link=https://www.javadoc.io/doc/org.meeuw/mihxil-time]

This collects some utility related to time (actually to Durations and Instants). The main purpose is to provide a way to represent uncertain values of time, but it also provides some utilities for working with `Clock`, and a utility to parse 'relative' times.

== Uncertain `java.time` objects

This module provides things like `org.meeuw.time.UcertainInstant` and `org.meeuw.time.UncertainDuration', which are very similar to their `java.time` equivalents, but implement also `UncertainNumber`, so basically represents temporary objects _with an uncertaintiy_ in their value.

== Clocks

Because some uncertain values may be related to event rates, you may also need some things related to clocks. Especially, in test cases.

=== `TestClock`

A clock which must be manually 'ticked'. This  is mainly useful for testing purposes.

=== `UniqueClock`

A clock for which each call is guaranteed to result an Instant strictly after all previous calls. This can be used in tests, but also in production code, for example to ensure that events are always uniquely ordered.

== Dynamic date time parsing

Can be found in `DynamicDateTime`. E.g. parse things like 'tomorrow' to actual time instances. This is based on https://github.com/mmbase/mmbase/blob/MMBase-1_9/core/src/main/javacc/org/mmbase/util/dateparser/DateParser.jj[old MMBase code]. It is a https://javacc.org[javacc-grammar]. I modernized it to be fully based on `java.time` classes, and also incorporate the 'event searchers' I added to https://natty-parser.github.io[natty].

=== syntax

[NOTE]
====
This section is work in progress
====

The most basic idea is:
[source]
----
[<base time>] [modifications]*
----
So, it starts with specifying some absolute time, which can be dynamic (refer to the current clock).

If no <base time> is specified, that implies 'now'.

Like so (where the current time is february 20, 2020)
|===
| Input | Output | remarks

| now  | 2020-02-20T20:20+01:00[Europe/Amsterdam] |
| | 2020-02-20T20:20+01:00[Europe/Amsterdam] | 'now' is the default, so the empty string is valid too.
| today | 2020-02-20T00:00+01:00[Europe/Amsterdam]  | start with some rounded value
| tohour | 2020-02-20T20:00+01:00[Europe/Amsterdam]  | other unit than 'day' are possible too

| 1973-03-05T06:00 | 1973-03-05T06:00+01:00[Europe/Amsterdam] | just state it in ISO foramt
| 1973-03-05 | 1973-03-05T00:00+01:00[Europe/Amsterdam] | time is optional
|===

Then zero or more 'modifications' or 'offset' can be given. Most basically with + and -.

[options="header"]
|===
| Input | Output | remarks
| now + 5 minute | 2020-02-20T20:25+01:00[Europe/Amsterdam] |
| 2021-08-05T20:00 + 1 minute - 2 days | 2021-08-03T20:01+02:00[Europe/Amsterdam |
| next week | 2021-08-03T20:01+02:00[Europe/Amsterdam |
|===

There are also ways to set offsets which are not implicitly positive or negative. They just jump to some relevant time of some current period.

The offset can for example be something like 'this month', 'this day', or 'today', which basically arranges rounding

[options="header"]
|===
| Input | Output | remarks
| now this day | 2020-02-20T00:00+01:00[Europe/Amsterdam] |
| now tohour | 2020-02-20T20:00+01:00[Europe/Amsterdam] | 'to-' an alias for that too.
| 2025-08-30 teatime | 2025-08-30T16:00+02:00[Europe/Amsterdam]
| some other our indcation can be used too
|===

Finally, then entire thing can be post fixed and prefixed by an explicit timezone. The timezone defaults to `ZoneId#systemDefault`.

[options="header"]
|===
| Input | Output | remarks
| TZUTC today | 2025-11-23T00:00Z[UTC] |
|===



=== demo

Find link:https://mihxil.github.io/math/DEMO.html#demo_dynamicdate[a working demo] at github pages.

=== Comparison to MMBase

The parser in MMBase was actually implemented as an extension of `java.util.Date` itself (`org.mmbase.util.DynamicDate`), and was in that aspect simpler. But it was not a very good citizen because of that, because the actually value of the date could be 'dynamic', and sometimes that required some explicit conversion to a normal `java.util.Date` object. Turns out that date object can't be extended very well.

So, this idea was dropped. The parser was taken as is but, it was converted to parse to `java.time.ZonedDateTime` instead of `java.util.Date`, also a wrapper class was added `DynamicDateTime`, which can contain a bit of configuration for the parsing (like the `Clock` to use).

Also, inspired by natty, the 'event searchers' are added so the parser can also support holidays and other events like 'next spring'.



=== Comparison to natty

I always thought that for the use cases I saw natty was not a very good fit, and my own, old, mmbase utility was nicer.

- natty parses entire sentences, and tries to find all date-like strings in it, therefore, also it returns a complicated DateGroup object as a parse result
- DynamicDateTime always parses to one ZonedDateTime, or gives an exeption

The idea is that this can be used in configurations or requests that are dependent on the current time. E.g., 'give me all objects created between 2 weeks ago' and 'now'.  Using the parser, it can support this for you. It'll parse ISO dates, but also 'now' and similar things.


TODO: add more documentation

:leveloffset!:

:leveloffset: 1

= statistics

image:https://img.shields.io/maven-central/v/org.meeuw.math/mihxil-statistics.svg[Maven Central,link=https://search.maven.org/artifact/org.meeuw.math/mihxil-statistics]
image:https://www.javadoc.io/badge/org.meeuw.math/mihxil-statistics.svg?color=blue[javadoc,link=https://www.javadoc.io/doc/org.meeuw.math/mihxil-statistics]


Implementations of `DoubleElement`, which are based on calculating standard deviations on sets of incoming data, and use that as the uncertainty value.

Also, it includes some classes to keep track of 'sliding window' values of averages.

== Windowed events

.example of WindowedEventRate
[source,java]
----
WindowedEventRate rate = WindowedEventRate.builder()
            .bucketCount(50)
            .window(Duration.ofMinutes(50))
            .build();
rate.newEvent();
...
..
log.info("Measured rate: {} /s",  rate.getRate(TimeUnit.SECONDS) + " #/s");

log.info("Measured rate: {}", rate); // toString
----

.another example of WindowedEventRate
[source,java]
----

import org.meeuw.configuration.ConfigurationService;
import org.meeuw.math.Interval;
import org.meeuw.math.text.configuration.UncertaintyConfiguration;
import org.meeuw.time.TestClock;
import org.meeuw.math.abstractalgebra.reals.RealNumber;
import org.meeuw.theories.abstractalgebra.UncertainDoubleTheory;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.data.Percentage.withPercentage;
import static org.meeuw.math.text.configuration.UncertaintyConfiguration.Notation.PARENTHESES;



...

ConfigurationService.withAspect(UncertaintyConfiguration.class, e -> e.withNotation(PARENTHESES),
    () -> {
        TestClock clock = new TestClock();
        try (WindowedEventRate rate = WindowedEventRate.builder()
            .window(Duration.ofSeconds(100))
            .bucketCount(10)
            .clock(clock)
            .build()) {
            for (int i = 0; i < 100; i++) {
                rate.accept(5 + (i % 3));
                clock.tick();
            }
            clock.tick(50);
            assertThat(rate.isWarmingUp()).isFalse();
            assertThat(rate.getRate()).isEqualTo(5.930038867295947);
            assertThat(rate.toString()).isEqualTo("5.9(1.8) /s");
        }
    });
----


== Statisticals

Just to keep track of averages and standard deviations of incoming data.


=== Statistical Long

Allow to enter 'longs' and similar objects.


Like durations


.keeps tracks of durations (in nanoseconds)
[source,java]
----
StatisticalLong mes = new StatisticalLong(DURATION_NS);

mes.enter(Duration.ofNanos(10), Duration.ofNanos(20));
assertThat(mes.durationValue()).isEqualTo(Duration.ofNanos(15));
assertThat(mes.optionalDurationValue()).contains(Duration.ofNanos(15));

assertThat(mes.getStandardDeviation()).isEqualTo(5.0d); // 5 ns

mes.enter(Duration.ofMinutes(5));

assertThat(mes.optionalDurationValue()).contains(Duration.parse("PT1M40.00000001S"));

----

=== Statistical Double

:leveloffset!:

:leveloffset: 1

= physics
image:https://img.shields.io/maven-central/v/org.meeuw.math/mihxil-physics.svg[Maven Central,link=https://search.maven.org/artifact/org.meeuw.math/mihxil-physics]
image:https://www.javadoc.io/badge/org.meeuw.math/mihxil-physics.svg?color=blue[javadoc,link=https://www.javadoc.io/doc/org.meeuw.math/mihxil-physics]


This module involves mostly around `PhysicalNumber` and its derivatives. A `PhysicalNumber` is a `DoubleElement`, but the uncertainty is stated (it is a `Measurement`), and knows how to propagate those uncertainties when doing algebraic operations.

Also, a `PhysicalNumber` can be assigned `Units`. This can be used for proper displaying the value, and for dimensional analysis.

.Example code for how measurements work
[source,java]
----

import static org.meeuw.physics.Measurement.measurement;
import static org.meeuw.physics.SI.DecimalPrefix.k;
import static org.meeuw.physics.SI.DecimalPrefix.none;
import static org.meeuw.physics.SI.*;
import static org.meeuw.physics.SIUnit.kg;
import static org.meeuw.physics.SIUnit.m;

...
PhysicalNumber twoLightYear = new Measurement(2, 0.1, ly);        //
PhysicalNumber oneParsec = measurement(1, 0.1, pc); // using the static import as a shortcut

assertThat(twoLightYear.plus(oneParsec).toString()).isEqualTo("5.3 ± 0.4 ly");
assertThat(oneParsec.plus(twoLightYear).toString()).isEqualTo("1.61 ± 0.13 pc");
assertThat(oneParsec.plus(twoLightYear).eq(twoLightYear.plus(oneParsec))).isTrue(); //different toString does not mean that they represent a different value
log.info(twoLightYear + "+" + oneParsec + "=" + twoLightYear.plus(oneParsec));
----

Physical numbers themselves are actually only forming a multiplicative group, because they cannot be added without constraints. In this example they can only be added to each other because both values have the same dimensions (both are about distance).

Physical numbers can freely be multiplied and divided by each other.

Objects of the statistic module can be converted to 'physical numbers' like so:
[source,java]
.event rate to measurement
----
WindowedEventRate rate = ...

PhysicalNumber measurement = new Measurement(rate);
PhysicalNumber rateInHours = measurement.toUnits(Units.of(SI.hour).reciprocal());


----

[source, java]
.statistical number to measurement
----
 StatisticalDouble statisticalDouble = new StatisticalDouble();
 statisticalDouble.enter(10d, 11d, 9d);

 PhysicalNumber measurement = new Measurement(statisticalDouble, Units.of(SI.min));

 assertThat(measurement.toUnits(Units.of(SIUnit.s)).toString()).isEqualTo("600 ± 45 s");
----

:leveloffset!:

:leveloffset: 1

= algebra
:gh: https://github.com/mihxil/math/
:ghraw: https://raw.githubusercontent.com/mihxil/math/main/
:ghblob: {gh}blob/main/
:ghm: {ghblob}mihxil-math/src/main/java/org/meeuw/math/
:gha: {ghblob}mihxil-algebra/src/main/java/org/meeuw/math/

image:https://img.shields.io/maven-central/v/org.meeuw.math/mihxil-algebra.svg[Maven Central,link=https://search.maven.org/search?q=g:%22org.meeuw.math%22]
image:https://javadoc.io/badge/org.meeuw.math/mihxil-algebra.svg?color=blue[javadoc,link=https://javadoc.io/doc/org.meeuw.math/mihxil-algebra]

This contains various implementations of the algebraic structure interfaces of `mihxil-math`. Like `RationalNumber` (modelling of rational numbers ℚ), and the rotation group SO(3).

== Features
=== Real numbers

The field of real numbers. Backed by java primitive `double`. A `RealNumber` is also 'uncertain', which is used to keep track of rounding errors.

- element  link:{gha}abstractalgebra/reals/RealNumber.java[`RealNumber`]
- structure link:{gha}abstractalgebra/reals/RealField.java[`RealField`]



=== Arbitrary-precision real numbers

The field of reals numbers, but backed by java's `BigDecimal`. This means that it supports arbitrary precision, but, since this still
is not _exact_ this still is uncertain, and rounding errors are propagated.

- element link:{gha}abstractalgebra/reals/BigDecimalElement.java[`BigDecimalElement`]
- structure link:{gha}abstractalgebra/reals/BigDecimalField.java[`BigDecimalField`]


=== Rational numbers

The field of rational numbers. Implemented using two arbitrary sized `BigIntegers`.

- element link:{gha}abstractalgebra/rationalnumbers/RationalNumber.java[`RationalNumber`]
- structure link:{gha}abstractalgebra/rationalnumbers/RationalNumbers.java[`RationalNumbers`]

Also, since division is exact in this field, this does _not_ implement `UncertainNumber`.

The cardinality is countable (ℵ~0~) so this _does_ implement `Streamable`.

=== Permutations

The permutation group. An example of a non-abelian finite group.

- element link:{gha}abstractalgebra/permutations/Permutation.java[`Permutation`]
- structure link:{gha}abstractalgebra/permutations/PermutationGroup.java[`PermutationGroup`]

This is group is finite, so streamable. This means that the group also contains an implementation of 'all permutations' (this is non-trivial, it's using Knuth's algorithm).

The permutation elements themselves are implemented as a `java.util.function.UnaryOperator` on `Object[]` which then performs the actual permutation.


=== Integers
The most basic algebraic structure which can be created from integers are the integers (ℤ) themselves. They form a ring:

- element link:{gha}abstractalgebra/integers/IntegerElement.java[`IntegerElement`]
- structure link:{gha}abstractalgebra/integers/Integers.java[`Integers`]


=== Even integers
As an example of a 'rng' (a ring without the existence of the multiplicative identity 1), the even integers can serve

- element link:{gha}abstractalgebra/integers/EvenIntegerElement.java[`EvenIntegerElement`]
- structure link:{gha}abstractalgebra/integers/EvenIntegers.java[`EvenIntegers`]

=== Natural numbers
In the natural numbers ℕ (the non-negative integers), there can be no subtraction. So they only form a 'monoid' (both additive and multiplicative).

- element link:{gha}abstractalgebra/integers/NaturalNumber.java[`NaturalNumber`]
- structure link:{gha}abstractalgebra/integers/NaturalNumbers.java[`NaturalNumbers`]

=== Modulo groups
Integers can be simply restricted via modulo arithmetic to form a finite ring:

- element link:{gha}abstractalgebra/integers/ModuloRingElement.java[`ModuloRingElement`]
- structure link:{gha}abstractalgebra/integers/ModuloRing.java[`ModuloRing`]

If the 'divisor' is a prime, then they even form a field, because the reciprocal can be defined:

- element link:{gha}abstractalgebra/integers/ModuloFieldElement.java[`ModuleFieldElement`]
- structure link:{gha}abstractalgebra/integers/ModuloField.java[`ModuloField`]

=== Complex numbers

Another well-known field is the field of complex numbers.

- element link:{gha}abstractalgebra/complex/ComplexNumber.java[`ComplexNumber`]
- structure link:{gha}abstractalgebra/complex/ComplexNumbers.java[`ComplexNumbers`]

=== Quaternions

Quaternions are forming a 'non-commutative' field, a link:{ghm}abstractalgebra/DivisionRing.java[DivisionRing]

- element link:{gha}abstractalgebra/quaternions/Quaternion.java[`Quaternion`]
- structure link:{gha}abstractalgebra/quaternions/Quaternions.java[`Quaternions`]

=== Matrix and rotation groups

==== SO(3)

Another non-abelian (not-commutative) multiplicative group.

- element link:{gha}abstractalgebra/dim3/Rotation.java[`Rotation`]
- structure link:{gha}abstractalgebra/dim3/RotationGroup.java[`RotationGroup`]

=== Strings

Actually, one of the simplest algebraic object you can think of are the strings. They form an additive monoid, an algebraic structure with only one operation (addition).

- element link:{gha}abstractalgebra/strings/StringElement.java[`StringElement`]
- structure link:{gha}abstractalgebra/strings/StringMonoid.java[`StringMonoid`]

Their cardinality is only ℵ~0~, so `StringMonoid` also contains an implementation to stream all possible strings.

=== Vector spaces

link:{ghm}abstractalgebra/VectorSpace.java[Vector spaces], which manage link:{ghm}abstractalgebra/Vector.java[`vectors`], are basically fixed sized sets of  link:{ghm}abstractalgebra/ScalarFieldElement.java[`scalars`], but combine that with several vector operations like cross and inner products.



:leveloffset!:

:leveloffset: 1

= Shapes [[shapes]]
:gh: https://github.com/mihxil/math/
:ghblob: {gh}blob/main/
:ghraw: https://raw.githubusercontent.com/mihxil/math/main/
:docs: {ghraw}docs
:iwidth: 200





image:https://img.shields.io/maven-central/v/org.meeuw.math/mihxil-shapes.svg[Maven Central,link=https://search.maven.org/search?q=g:%22org.meeuw.math%22]
image:https://www.javadoc.io/badge/org.meeuw.math/mihxil-shapes.svg?color=blue[javadoc,link=https://www.javadoc.io/doc/org.meeuw.math/mihxil-shapes]

The `shapes` modules contains implementations for several 2 and 3-dimensional shapes, like circles, spheres, and polygons.

[source,java]
----

import org.meeuw.configuration.ConfigurationService;
import org.meeuw.math.abstractalgebra.integers.ModuloFieldElement;
import org.meeuw.math.abstractalgebra.reals.RealNumber;
import org.meeuw.math.shapes.dim2.*;
import org.meeuw.math.svg.SVG;
import org.meeuw.math.svg.SVGDocument;
import org.meeuw.math.text.configuration.NumberConfiguration;
import org.meeuw.math.text.configuration.UncertaintyConfiguration;

import static org.meeuw.math.abstractalgebra.reals.RealField.element;
import static org.meeuw.math.svg.SVGDocument.defaultSVG;


....


@ParameterizedTest
@ValueSource(ints = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20})
public void regularPolygons(int n ) throws Exception {

    RegularPolygon<RealNumber> polygon = RegularPolygon.withCircumScribedRadius(n, element(100.0));

    SVGDocument document = defaultSVG()
        .withSize(size)
        .addGrid(b -> b.spacing(spacing))
        .addInfo()
        .addRegularPolygon(polygon, s -> s
            .circumscribedCircle(true)
            .circumscribedRectangle(true)
            .inscribedCircle(true)
        )
        ;

    try (FileOutputStream fos = new FileOutputStream(new File(dest,  n +"-gon.svg"))) {
        SVG.marshal(document, new StreamResult(fos));
    }
}

@Test
public void rotatedPolygon() throws Exception {
    try (FileOutputStream fos = new FileOutputStream(new File(dest,   "rotated-3-gon.svg"))) {
        SVG.marshal(defaultSVG()
            .withSize(size)
            .addGrid(b -> b.spacing(spacing))
            .addInfo()
            .addRegularPolygon(
                RegularPolygon.withCircumScribedRadius(3, element(size.width().doubleValue() / 2)).rotate(element(Math.toRadians(10.0))),
                s -> s
                    .circumscribedCircle(true)
                    .circumscribedRectangle(true)
                    .inscribedCircle(true)
            ), new StreamResult(fos));
    }
}

----
image:{docs}/shapes/3-gon.svg[width={iwidth},title="triangle", link="{docs}/shapes/3-gon.svg"]
image:{docs}/shapes/rotated-3-gon.svg[width={iwidth},title="triangle", link="{docs}/shapes/rotated-3-gon.svg"]
image:{docs}/shapes/4-gon.svg[width={iwidth},title="square", link="{docs}/shapes/4-gon.svg"]
image:{docs}/shapes/5-gon.svg[width={iwidth},title="pentagon", link="{docs}/shapes/5-gon.svg"]
image:{docs}/shapes/6-gon.svg[width={iwidth},title="hexagon", link="{docs}/shapes/6-gon.svg"]
image:{docs}/shapes/7-gon.svg[width={iwidth},title="heptagon", link="{docs}/shapes/7-gon.svg"]
image:{docs}/shapes/8-gon.svg[width={iwidth},title="octagon", link="{docs}/shapes/8-gon.svg"]
image:{docs}/shapes/9-gon.svg[width={iwidth},title="nonagon", link="{docs}/shapes/9-gon.svg"]
image:{docs}/shapes/10-gon.svg[width={iwidth},title="decagon", link="{docs}/shapes/10-gon.svg"]

[source,java]
----
@Test
public void rectangle() throws Exception {
    Rectangle<RealNumber> rectangle = new Rectangle<>(element(100.0), element(170.0)).rotate(element(Math.toRadians(10.0)));

    SVGDocument svg = defaultSVG()
        .withSize(size)
        .addGrid(b -> b.spacing( spacing))
        .addInfo()
        .addPolygon(rectangle, s -> {
            s.circumscribedCircle(true);
            s.circumscribedRectangle(true);

        });
    try (FileOutputStream fos = new FileOutputStream(new File(dest,  "rectangle.svg"))) {
        SVG.marshal(svg.buildDocument(), new StreamResult(fos));
    }
}

@Test
public void circle() throws Exception {
    try (FileOutputStream fos = new FileOutputStream(new File(dest,  "circle.svg"))) {
        SVG.marshal(defaultSVG()
            .withSize(size)
            .addGrid(b -> b.spacing(spacing))
            .addInfo()
            .addCircle(new Circle<>(element(100.0)), s -> s
                .circumscribedRectangle(true)
                .circumscribedRectangleAttributes(e -> {
                    e.setAttribute("stroke", "red");
                    }
                )
            )
            .buildDocument(),
            new StreamResult(fos)
        );
    }
}

@Test
public void ellipse() throws Exception {
    Ellipse<RealNumber> ellipse = new Ellipse<>(element(100.0), element(80.0), element(Math.toRadians(45.0)));

    SVGDocument document = defaultSVG()
        .withSize(size)
        .addGrid(b -> b.spacing(spacing))
        .addInfo()
        .addEllipse(ellipse, s -> s
            .circumscribedCircle(true)
            .circumscribedRectangle(true)
        );
    try (FileOutputStream fos = new FileOutputStream(new File(dest,  "ellipse.svg"))) {
      SVG.marshal(document.buildDocument(), new StreamResult(fos));
    }
}
----

image:{docs}/shapes/rectangle.svg[width={iwidth},title="rectangle", link="{docs}/shapes/rectangle.svg"]
image:{docs}/shapes/circle.svg[width={iwidth},title="circle", link="{docs}/shapes/circle.svg"]
image:{docs}/shapes/ellipse.svg[width={iwidth},title="ellipse", link="{docs}/shapes/ellipse.svg"]

:leveloffset!:

:leveloffset: 1

= Theory testing [[theories]]
:gh: https://github.com/mihxil/math/
:ghblob: {gh}blob/main/
:ght: {ghblob}mihxil-theories/src/main/java/

image:https://img.shields.io/maven-central/v/org.meeuw.math/mihxil-theories.svg[Maven Central,link=https://search.maven.org/artifact/org.meeuw.math/mihxil-theories]
image:https://www.javadoc.io/badge/org.meeuw.math/mihxil-theories.svg?color=blue[javadoc,link=https://www.javadoc.io/doc/org.meeuw.math/mihxil-theories]

NOTE::

Package structure was changed in `0.12.0`.

For testing the structures and object of link:{gh}[mihxil-math], this provides 'property-based' testing, based on link:https://jqwik.net/[jqwik].

This is provided as a set of interfaces named `...Theory`. Tests can implement these interfaces, and all contracts are tested. This normally requires the tests to implement a set of datapoints ore 'elements'.

== Non math related theories

See link:{ght}org/meeuw/theories[`org.meeuw.theories`] for theories not directly related to mathematical structures, but merely to java contracting like e.g.


|===
|class | goal | (example) methods

|link:{ght}org/meeuw/theories/BasicObjectTheory.java[BasicObjectTheory]
|Tests basic properties of any java object, mainly consistency of `equals` and `hashCode`
| `equalsIsReflexive`
  `equalsIsSymmetric`
  `equalsIsTransitive`
  `equalsIsConsistent`
  `equalsReturnFalseOnNull`
  `hashCodeIsSelfConsistent`
  `hashCodeIsConsistentWithEquals`
  `toString`

|link:{ght}org/meeuw/theories/ComparableTheory.java[ComparableTheory]
|If an object is also `Comparable` then consistency of `compareTo` can be tested
| `equalsConsistentWithComparable`

|link:{ght}org/meeuw/theories/CharSequenceTheory.java[CharSequenceTheory]
|The `CharSequence` interface also has a few methods that can be tested generically
| `charAtIsConsistentWithToStringCharAt`
  `subSequenceIsConsistent`
|===


:leveloffset!:

:leveloffset: 1

= ConfigurationService [[configuration_service]]

image:https://img.shields.io/maven-central/v/org.meeuw.configuration/mihxil-configuration.svg[Maven Central,link=https://search.maven.org/artifact/org.meeuw.configuration/mihxil-configuration]
image:https://www.javadoc.io/badge/org.meeuw.configuration/mihxil-configuration.svg?color=blue[javadoc,link=https://www.javadoc.io/doc/org.meeuw.configuration/mihxil-configuration]

`ConfigurationService` is responsible for managing the `Configuration` thread locals.

Like this it can be consulted

.Accessing configuration
[source,java]
----
import org.meeuw.configuration.Configuration;
import org.meeuw.configuration.ConfigurationService;
import org.meeuw.math.text.configuration.NumberConfiguration;
import org.meeuw.math.text.configuration.UncertaintyConfiguration;

import static org.meeuw.configuration.ConfigurationService.*;
...

Configuration configuration = getConfiguration();
NumberConfiguration aspect = configuration.getAspect(NumberConfiguration.class);
int minimalExponent = aspect.getMinimalExponent();
----
This would however probably mainly be used in _implementations_.

Actual configuration can be done in two basically distinct ways.

- a new configuration object can be set as a thread local
- global default configuration object can be set

.temporary overrides
[source,java]
----

{
    //noinspection resource
    setConfiguration(builder ->
        builder.configure(NumberConfiguration.class,
            (numberConfiguration) -> numberConfiguration.withMinimalExponent(8)
        )
    );

    //...code...
    ConfigurationService.resetToDefaults();
}

// or using Autocloseable
try (Reset ignored = setConfiguration(builder ->
    builder.configure(NumberConfiguration.class,
        (numberConfiguration) -> numberConfiguration.withMinimalExponent(8)
    )
)) {
    ;
    //...code...
}
----

There are some utilities in `ConfigurationService` that makes this process a bit easier.

.temporary overrides utilities
[source, java]
----
withConfiguration((con) ->
        con.configure(UncertaintyConfiguration.class,
                (uncertaintyConfiguration) -> uncertaintyConfiguration.withNotation(UncertaintyConfiguration.Notation.PARENTHESES))
            .configure(NumberConfiguration.class,
                (numberConfiguration) -> numberConfiguration.withMinimalExponent(3))
    , () -> {
        // code

    });
----

Global defaults can be set similarly

.setting global defaults
[source,java]
----
defaultConfiguration((configurationBuilder) ->
    configurationBuilder.configure(NumberConfiguration.class, c -> c.withMinimalExponent(4))
        .configure(UncertaintyConfiguration.class, c -> c.withNotation(UncertaintyConfiguration.Notation.PLUS_MINUS))
);
----

ConfigurationService itself is not actually math related, and is released in a separate artifact.


:leveloffset!:




:leveloffset: 1

= Compatibility

This project is compiled with java 17, and provides JPMS module info,  until version `0.16.x` it was compatible with java 8.

:leveloffset!:

:leveloffset: 1

= History

I'm maintaining this mainly as a hobby project.


|===
|Version |Date  |Remarks

| 1.0
| ?
| Refactory physical units, to be agnostic about axes.


| 0.19
| july, 2025
|
 Introduces also the 'arithmetic' package, which contains an AST implementation to represent combination of operators and elements.

 `mihxil-time` now also has support for dynamic date parsing

Set up running demo's with `cheerpj`


| 0.18
| june, 2025
| org.meeuw.math.time became org.meeuw.time, and a new module mihxil-time

|0.17
| june, 2025
| disband java 8 support, require at least java 17

|0.16
| june, 2025
| Introduction of shapes.

|0.15
|2025
|Refactoring related to uncertain duration/ instants

| 0.14
|2024-12
|


|===

:leveloffset!:

:leveloffset: 1

= Asciidoc[[asciidoc]]

I use https://asciidoc.org/[asciidoc] to write documentation for this.

I think it is nicer than Markdown. Sadly, A few things don't work entirely when rendered by GitHub.

- It seems to run in 'SECURE' mode, so includes are not working
- It seems to also miss things like support
  * for LaTeX formulas
  * embedding of YouTube videos.
  * adding docinfo, which is used here and there to add javascript and style for working demo's

I worked around the first thing by a GitHub action 'reducing' the .adoc, which effectively resolves the includes (and produces the `README.adoc` files from the `README-source.adoc` files). This way some modules have their own documentation, which is then included as chapter of the overall documentation.  Also, includes are used to include example code from _actual_ code (like test cases). The README.adoc files then render directly 'mostly' as intended.

The other things (formula's, video's and docinfo) could (I presume) only be worked around by transforming the entire thing to HTML, which happens in the `publish-documentation` action. A drawback is that the documentation is less tight to GitHub itself, and you need to access https://mihxil.github.io/math/[a different url], but every detail should be working there.



:leveloffset!:
