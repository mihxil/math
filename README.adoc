= math
:toc:
:toclevels: 4
:stem:
:source-highlighter: coderay


//image:https://travis-ci.com/mihxil/math.svg?[Build Status,link=https://travis-ci.com/mihxil/math]
image:https://github.com/mihxil/math/workflows/build/badge.svg?[Build Status,link=https://github.com/mihxil/math/actions?query=workflow%3Abuild]
image:https://codecov.io/gh/mihxil/math/branch/master/graph/badge.svg[codecov,link=https://codecov.io/gh/mihxil/math]
image:https://img.shields.io/maven-central/v/org.meeuw/mihxil-math.svg?label=Maven%20Central[Maven Central,link=https://search.maven.org/search?q=g:%22org.meeuw%22]
image:https://img.shields.io/nexus/s/https/oss.sonatype.org/org.meeuw.math/mihxil-math.svg[snapshots,link=https://oss.sonatype.org/content/repositories/snapshots/org/meeuw/math/]
image:http://www.javadoc.io/badge/org.meeuw/mihxil-math.svg?color=blue[javadoc,link=http://www.javadoc.io/doc/org.meeuw/mihxil-math]

Math and physics related classes.

ifdef::env-github[]
See link:https://mihxil.github.io/math/[this file in html] for proper display of the (few) mathematical equations.
endif::[]


== mihxil-math

The common dependency of the modules in the project. It provides the scaffolding for:

- abstract algebra's to ensure a common interface for basic operations. Java does not provide operator overloading. But this is some way even better. The basic algebraic operations are formalized in strict mathematically definied interfaces. Implementation of these interfaces can be 'property-based' tested, to make sure that the implementation indeed adhere to the contracts.
- An 'uncertain number' interface, plus an implemention of an algebraic field of uncertain numbers.
- An SPI for formatting the elements of abstract algebra's, and an implementation to format these uncertain number, using proper rounding and scientific notation.

=== Abstract Algebras

The idea is that every 'abstract algebra' consists of the implementation of two interfaces.

- One of the extensions of  link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/AlgebraicElement.java[`org.meeuw.math.abstractalgebra.AlgebraicElement`] defines the properties of all elements of the algebra. It also should implement the actual operations like multiplication and addition.

- One of the corresponding extensions of link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/AlgebraicStructure.java[`org.meeuw.math.abstractalgebra.AlgebraicStructure`], e.g.  link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/Field.java[`org.meeuw.math.abstractalgebra.Field`].

The terminology which is adopted is this:

|===
|Algebraic operation  | operator | operator name | static operator name | result name | argument name | defined in

|addition | + | plus | add | sum | summand
| link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/AdditiveSemiGroupElement.java[`AdditiveSemiGroupElement`]
|subtraction | - | minus | subtract | difference | subtrahend | link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/AdditiveGroupElement.java[`AdditiveGroupElement`]
|multiplication |  ⋅  | times | multiply | product | multiplier | link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/MultiplicativeSemiGroupElement.java[`MultiplicativeSemiGroupElement`]
|division | / | dividedBy | divide | quotient |  divisor | link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/MultiplicativeGroupElement.java[`MultiplicativeGroupElement`]
|negation      | - | negation | negate | negation|| link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/AdditiveGroupElement.java[`AdditiveGroupElement`]
|reciprocation | 1/ |  reciprocal | | reciprocal|| link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/MultiplicativeGroupElement.java[`MultiplicativeGroupElement`]
|exponentiation | ^ | pow | pow | power| exponent| link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/CompleteFieldElement.java[`CompleteFieldElement`]
|square root | √ | sqrt | radicand
 | square root| | link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/CompleteFieldElement.java[`CompleteFieldElement`]
|sine | `sin()`| sin | sin | sine| angle | link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/CompleteFieldElement.java[`CompleteFieldElement`]
|cosine | `cos()` | cos | cos | cosine| angle | link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/CompleteFieldElement.java[`CompleteFieldElement`]
|metric or distance| `d()` | distanceTo | metric | distance|| link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/MetricSpaceElement.java[`MetricSpaceElement`]
|absolute value, distance to zero|  \|\|  | abs| abs| absolute value|| link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/MetricSpaceElement.java[`MetricSpaceElement`]

|===

The methods on the elements take the name of the corresponding operator. So e.g.:

[source,java]
----
RationalNumber e1, e2, e3;
e3 = e1.times(e2);
----

These methods always take the value of the element itself plus zero parameters (for the unary operators) or one parameter (for the binary operators), and create a new value from the same algebra.

Alternative terminology, like e.g. 'add' for addition would have been possible, but it was chosen to use those verbs when the operation is e.g. implemented statically (`void add(e1, e2)`) or are modifying the element itself.

Most implementations are strictly read-only, but at least all algebraic operations themselves should be without side effects on the algebraic element itself.



==== Algebraic structure

Every algebraic element object has a reference to (the same)  instance of this structure. The structure itself defines e.g. the 'cardinality'. If the cardinality is 'countable' (< ℵ~1~), the structure can also implement  link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/Streamable.java[`Streamable`] to actually produce all possible elements.

The algebraic structure will also contain methods to obtain 'special elements' like the identity elements for multiplication and addition ('one' and 'zero').

==== Numbers

Some algebraic elements are like 'real' numbers. There are several interfaces dedicated to formalising properties of that.

|===
| class/interface  | description

| link:mihxil-math/src/main/java/org/meeuw/math/numbers/Scalar.java[`Scalar`] | generic interface that defines method to convert to java (primitive) number objects. Like `doubleValue()` and `intValue()`. it extends a few interfaces for some properties which can be applied to other structures to, like `Sizeable` and `SignedNumber`.
 | link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/ScalarFieldElement.java[`ScalarFieldElement`] | A `Scalar` that is also a `FieldElement`. So this is the link from number to algebra.  We well behaves field element that also behaves as a 'Number' may implement `ScalarFieldElement`
| link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/CompleteFieldElement.java[`CompleteFieldElement`] | Even more similar to the everyday concept of number an algebraic field element becomes if it is 'complete', this in some way means 'no gaps', but essentially boils down to the fact that operations like taking square roots and trigonometric function are possible.
| link:mihxil-math/src/main/java/org/meeuw/math/numbers/NumberOperations.java[`NumberOperations`] |

|===


==== Numbers and propagation of uncertainties

For real numbers it is true that most of them  cannot be represented exactly, and it may be of interest to keep track of the uncertainty in the value, and try to propagate those uncertainties sensibly when performing operations on the numbers.

The 'physics' module will add to this that these kinds of uncertainties may originate not only in the finite nature of representing them, but also in the limitations of actually _measuring_ things.

The 'statistics' module introduces 'uncertain' numbers where the uncertainty is the standard deviation in a collected set of values. These numbers are examples where the numbers are actually stateful, because new values can be added to the set. This should not actually change the _value_ represented by  the object though, only decrease its _uncertainty_. On performing operations on these kinds of objects you would receive unmodifiable stateless other objects with frozen value and uncertainty.

It is not always an absolute choice on how propagations must happen, some interpretation may be needed sometimes. The choices made are currently collected in `UncertaintyNumberOperations', which is not currently pluggable or configurable, but it may well be.

|===
| operation | formula | current uncertainty propagation algorithm

| summation | latexmath:[a ± Δa + b ± Δb] | latexmath:[\sqrt{Δa^2 + Δb^2}]
| multiplication | latexmath:[a ± Δa \cdot b ± Δb] | ..
| exponentiation | |
| sin/cos | latexmath:[\sin(\alpha \pm \Delta\alpha)] | latexmath:[\Delta\alpha]|
|===

===== Zero

Sometimes the value with uncertainty is exactly _zero_, so fractional uncertainty leads to division by zero exceptions. Therefor for now fractional uncertainity is implemented like latexmath:[ \frac{Δa}{|a| +  Δa}] (rather then latexmath:[ \frac{Δa}{|a|}]), where the denominator can never become zero because the uncertainty is strictly bigger than zero.


==== Testing

In link:mihxil-math-theories/src/main/java/org/meeuw/math/abstractalgebra/test/[mihxil-math-theories] for every algebraic structure interface there are 'theory' interfaces using link:https://jqwik.net/[jqwik]. Tests for actual implementation implement these interfaces and provide the code to supply a bunch of example link:https://github.com/mihxil/math/blob/3d216db560e1930aff890cf11c3f63f56b002710/mihxil-math-theories/src/main/java/org/meeuw/math/abstractalgebra/test/ElementTheory.java#L20[`elements`].

Default methods then test wheter all theoretical possibilities and limitation of the algebraic structure are indeed working.

==== Implementation of equals/hashcode

When a value has uncertainty then 'equals' also considers it. So objects may e.g. have different `toString` representation but still be equal, because the difference is considered smaller than te uncertainty, and so the values are at 'probably' equals.

In this case the `hashCode` must be a fixed value, because otherwise we can't garantuee that equal values have equal hashCode.

So it's a bad idea to use uncertain values as hash keys.

=== Formatting

A service loader is provided which provides implementations of `AlgebraicElementFormatProvider` which can create instances of `java.text.Format` which in turn can be used to convert algebraic elements to a string. `#toString` can be based on it.

The formatters have access to a (thread local) configuration object. This way a consistent way is available to configure how e.g. uncertainties must be represented. Currently, this configuration object can only be filled by code. The base configuration object in itself is empty, but the available `AlgebraicElementFormatProvider`  communicate the 'configuration aspects' which it can use.


The service giving access to the format-providers is `FormatService`. It is also responsible for managing the `Configuration` thread locals.

Like this it can be consulted

.Accessing configuration
[source,java]
----
import static org.meeuw.math.text.spi.FormatService.*;

 Configuration configuration = FormatService.getConfiguration();
 NumberConfiguration aspect = configuration.getAspect(NumberConfiguration.class);
 int minimalExponent = aspect.getMinimalExponent();
----
This would however probably mainly be used in _implementations_. Actual configuration can be done in two basicly distinct ways.

- global defaults can be set
- for a block these can be overriden

.setting global defaults
[source,java]
----
 FormatService.defaultConfiguration((con) ->
  con.aspect(NumberConfiguration.class, c -> c.withMinimalExponent(4))
     .aspect(TestConfigurationAspect.class, c -> c.withSomeInt(-1))
 );
----

.temporary overrides
[source,java]
----
 FormatService.with((con) -> con
   .aspect(TestConfigurationAspect.class, (tc) -> tc.withSomeInt(5))
   .aspect(NumberConfiguration.class, (tc) -> tc.withMinimalExponent(3))
   , () -> {
     assertThat(FormatService.getConfigurationAspect(TestConfigurationAspect.class).getSomeInt()).isEqualTo(5);
     assertThat(FormatService.getConfigurationAspect(NumberConfiguration.class).getMinimalExponent()).isEqualTo(3);

 });
----

== mihxil-statistics

Implementations of `UncertainDouble`, based on calculating standard deviations on sets of incoming data, and using that as the uncertainty value.

Also, it includes some classes to keep track of 'sliding window' values of averages.




== mihxil-physics

This module involves mostly around `PhysicalNumber` and its derivatives. A `PhysicalNumber` is a `UncertainDouble`, but the uncertainty is stated (it is a `Measurement`), and knows how to propagate those uncertainties when doing algebraic operations.

Also, a `PhysicalNumber` can be assigned `Units`. This can be used for proper displaying the value, and for dimensional analysis.

[source,java]
----
PhysicalNumber twoLightyears = new Measurement(2, 0.1, SI.ly);
PhysicalNumber oneParsec = new Measurement(1, 0.1, SI.pc);
log.info("{} + {} = {}", twoLightyears, oneParsec, twoLightyears.plus(oneParsec));
assertThat(twoLightyears.plus(oneParsec).toString()).isEqualTo("5.3 ± 0.3 ly");
assertThat(oneParsec.plus(twoLightyears).toString()).isEqualTo("1.61 ± 0.10 pc");
assertThat(oneParsec.plus(twoLightyears)).isEqualTo(twoLightyears.plus(oneParsec)); //different toString does not mean that they represent a different value.

----

Physical numbers themselves are actually only forming a multiplicative group, because they cannot be added without constraints. In this example they can only be added to each other because both values have the same dimensions (both are about distance).

Physical numbers can freely multiplied and divided by each other.


== mihxil-algebra

This contains various implementations of the algebraic structure interfaces of `mihxil-math`. Like `RationalNumber` (modelling of rational numbers ℚ), and the rotation group SO(3).

=== Features
==== Real numbers

The field of real numbers. Backed by java primitive `double`. A `RealNumber` is also 'uncertain', which is used to keep track of rounding errors.

- element  link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/reals/RealNumber.java[`RealNumber`]
- structure link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/reals/RealField.java[`RealField`]



==== Arbitrary precision real numbers

The field of reals numbers, but backed by java's `BigDecimal`. This means that it supports arbitrary precision, but, since this still
is not _exact_ this still is uncertain, and rounding errors are propagated.

- element link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/reals/BigDecimalElement.java[`BigDecimalElement`]
- structure link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/reals/BigDecimalField.java[`BigDecimalField`]


==== Rational numbers

The field of rational numbers. Implemented using two arbitrary sized `BigIntegers`.

- element link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/rationalnumbers/RationalNumber.java[`RationalNumber`]
- structure link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/rationalnumbers/RationalNumbers.java[`RationalNumbers`]

Also, since division is exact in this field, this does _not_ implement `UncertainNumber`.

The cardinality is countable (ℵ~0~) so this _does_ implement `Streamable`.

==== Permutations

The permutation group. An example of a non-abelian finite group.

- element link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/permutations/Permutation.java[`Permutation`]
- structure link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/permutations/PermutationGroup.java[`PermutationGroup`]

This is group is finite, so streamable. This means that the group also contains an implementation of 'all permutations' (this is non-trivial, it's using Knuth's algorithm).

The permutation elements themselves are implemented as a `java.util.function.UnaryOperator` on `Object[]` which then performs the actual permutation.


==== Integers
The most basic algebraic structure which can be created from integers are the integers (ℤ) themselves. They form a ring:

- element link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/integers/IntegerElement.java[`IntegerElement`]
- structure link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/integers/Integers.java[`Integers`]


==== Even integers
As an example of a 'rng' (a ring without the existence of the multiplicative identity 1), the even integers can serve

- element link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/integers/EvenIntegerElement.java[`EvenIntegerElement`]
- structure link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/integers/EvenIntegers.java[`EvenIntegers`]

==== Natural numbers
In the natural numbers ℕ (the non-negative integers), there can be no subtraction. So they only form a 'monoid' (both additive and multiplicative).

- element link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/integers/NaturalNumber.java[`NaturalNumber`]
- structure link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/integers/NaturalNumbers.java[`NaturalNumbers`]

==== Modulo groups
Integers can be simply restricted via modulo arithmetic to form a finite ring:

- element link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/integers/ModuloRingElement.java[`ModuloRingElement`]
- structure link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/integers/ModuloRing.java[`ModuloRing`]

If the 'divisor' is a prime, then they even form a field, because the reciprocal can be defined:

- element link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/integers/ModuloFieldElement.java[`ModuleFieldElement`]
- structure link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/integers/ModuloField.java[`ModuloField`]

==== Complex numbers

Another well-known field is the field of complex numbers.

- element link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/complex/ComplexNumber.java[`ComplexNumber`]
- structure link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/complex/ComplexNumbers.java[`ComplexNumbers`]

==== Quaternions

Quaternions are forming a 'non-commutative' field, a link:mihxil-math/src/main/java/org/meeuw/math/abstractalgebra/DivisionRing.java[DivisionRing]

- element link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/quaternions/Quaternion.java[`Quaternion`]
- structure link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/quaternions/Quaternions.java[`Quaternions`]

==== Matrix and rotation groups

===== SO(3)

Another non-abelian (not-commutative) multiplicative group.

- element link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/dim3/Rotation.java[`Rotation`]
- structure link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/dim3/RotationGroup.java[`RotationGroup`]

==== Strings

Actually one of the simplest algebraic object you can think of are the strings. They form an additive monoid, an algebraic structure with only one operation (addition).

- element link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/strings/StringElement.java[`StringElement`]
- structure link:mihxil-algebra/src/main/java/org/meeuw/math/abstractalgebra/strings/StringMonoid.java[`StringMonoid`]

Their cardinality is only ℵ~0~, so `StringMonoid` also contains an implementation to stream all possible strings.

==== Vector spaces






