<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>Demo</title>
<link rel="stylesheet" href="./index.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
<meta name="keywords" content="open source, documentation" />
<meta name="demo" content="demo" />
<script src="https://cjrtnc.leaningtech.com/20250907_2731/loader.js"></script>
<!--script src="https://cjrtnc.leaningtech.com/4.2/loader.js"></script-->

<script src="resources/demo.js" type="module" ></script>
<script src="resources/calculator.js" type="module" ></script>
<script src="resources/dynamicdate.js" type="module" ></script>
<script src="resources/solver.js" type="module" ></script>
<link rel="stylesheet" href="resources/css/demo.css" />
<!--link rel="stylesheet" href="resources/calculator.css" /-->


</head>
<body id="demo_section" class="article">
<div id="header">
<h1>Demo</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#demo_calculator">Calculator</a></li>
<li><a href="#demo_solver">Solver</a></li>
<li><a href="#demo_dynamicdate">Dynamic date parsing</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>These are a running <a href="https://webassembly.org/">webassembly</a> demos (using <a href="https://cheerpj.com/docs/getting-started/Java-library">cheerpj</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This section is work in progress</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1 tips-aside">
<h2 id="demo_calculator">Calculator</h2>
<div class="sectionbody">
<form id="calculator" class="demo">
  <label for="calculator_field">Field:</label>
  <select id="calculator_field"  >
   <!-- filled by calculator.js -->
  </select>
  <div class="help"></div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div id="calculator_digits" class="dlist">
<dl>
<dt class="hdlist1">0</dt>
<dt class="hdlist1">1</dt>
<dt class="hdlist1">2</dt>
<dt class="hdlist1">3</dt>
<dt class="hdlist1">4</dt>
<dt class="hdlist1">5</dt>
<dt class="hdlist1">6</dt>
<dt class="hdlist1">7</dt>
<dt class="hdlist1">8</dt>
<dt class="hdlist1">9</dt>
</dl>
</div>
<div id="calculator_operators" class="dlist">
<dl>
<dt class="hdlist1">+</dt>
<dd>
<p>for addition</p>
</dd>
<dt class="hdlist1">-</dt>
<dd>
<p>for subtraction</p>
</dd>
<dt class="hdlist1">‚ãÖ</dt>
<dd>
<p>for multiplication</p>
</dd>
<dt class="hdlist1">/</dt>
<dd>
<p>for division</p>
</dd>
<dt class="hdlist1">\</dt>
<dd>
<p>for euclidean division</p>
</dd>
<dt class="hdlist1">%</dt>
<dd>
<p>for modulo division</p>
</dd>
<dt class="hdlist1">*</dt>
<dd>
<p>for the default 'group operation'</p>
</dd>
<dt class="hdlist1">^</dt>
<dd>
<p>for exponentiation</p>
</dd>
</dl>
</div>
<div id="calculator_unary_operator" class="dlist">
<dl>
<dt class="hdlist1">-</dt>
<dd>
<p>negation</p>
</dd>
</dl>
</div>
<div id="calculator_special" class="dlist">
<dl>
<dt class="hdlist1">( )</dt>
<dd>
<p>brackets</p>
</dd>
<dt class="hdlist1">""</dt>
<dd>
<p>quotes</p>
</dd>
</dl>
</div>
</td>
</tr>
</table>
</div>
<div class="form">
  <label for="calculator_toparse">Expression to evaluate: <span class="help"></span></label> <input type="text" id="calculator_toparse"  list="calculator_toparse-examples" value="" />
   <datalist id="calculator_toparse-examples">
   <!-- filled by calculator.js -->
   </datalist>
  <button name="submit">=</button>
  <output id="calculator_output" for="calculator_toparse"> </output>
</div>
</form>
<details>
<summary class="title">java</summary>
<div class="content">
<div class="paragraph">
<p>This is the source code for the above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Getter</span>
<span class="directive">public</span>  <span class="type">enum</span> FieldInformation {
    rational(RationalNumbers.INSTANCE, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 3/5</span><span class="delimiter">&quot;</span></span>),
    real(RealField.INSTANCE, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 3/5</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">sin(ùúã/2)</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">sqr(ùúë) - ùúë</span><span class="delimiter">&quot;</span></span>),
    bigdecimal(BigDecimalField.INSTANCE, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 3/5</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">sin(ùúã/2)</span><span class="delimiter">&quot;</span></span>),
    gaussian(GaussianRationals.INSTANCE, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 3/5</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="content">1 + 2i</span><span class="char">\&quot;</span><span class="content"> ‚ãÖ 8i</span><span class="delimiter">&quot;</span></span>),
    complex(ComplexNumbers.INSTANCE, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 3/5</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">sin(ùúã/2)</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">exp(-i ‚ãÖ ùúã)</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="content">2 + 3i</span><span class="char">\&quot;</span><span class="content"> ‚ãÖ i</span><span class="delimiter">&quot;</span></span>),
    bigcomplex(BigComplexNumbers.INSTANCE, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 3/5</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="content">1 + 2i</span><span class="char">\&quot;</span><span class="content"> ‚ãÖ 8i</span><span class="delimiter">&quot;</span></span>),
    quaternions(Quaternions.of(RationalNumbers.INSTANCE),
        <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 3/5</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="content">1 + 2i + 3j + 4k</span><span class="char">\&quot;</span><span class="content"> ‚ãÖ 8i</span><span class="delimiter">&quot;</span></span>),
    quaternions_bigdecimal(Quaternions.of(BigDecimalField.INSTANCE),
        <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 3/5</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="content">1 + 2i + 3j + 4k</span><span class="char">\&quot;</span><span class="content"> ‚ãÖ 8i</span><span class="delimiter">&quot;</span></span>),
    integers(Integers.INSTANCE, <span class="string"><span class="delimiter">&quot;</span><span class="content">4 ‚ãÖ 7</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">9 - 3</span><span class="delimiter">&quot;</span></span>),
    modulo10(ModuloRing.of(<span class="integer">10</span>), <span class="string"><span class="delimiter">&quot;</span><span class="content">4 ‚ãÖ 7</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">9 - 3</span><span class="delimiter">&quot;</span></span>),
    modulo13(ModuloField.of(<span class="integer">13</span>), <span class="string"><span class="delimiter">&quot;</span><span class="content">10 ‚ãÖ 7</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">10 - 3</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">12 ‚ãÖ 6 / 4</span><span class="delimiter">&quot;</span></span>),
    natural(NaturalNumbers.INSTANCE, <span class="string"><span class="delimiter">&quot;</span><span class="content">10 ‚ãÖ 7</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">10 - 3</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">12 ‚ãÖ 6 / 4</span><span class="delimiter">&quot;</span></span>),
    even(EvenIntegers.INSTANCE, <span class="string"><span class="delimiter">&quot;</span><span class="content">10 ‚ãÖ 8</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">10 - 4</span><span class="delimiter">&quot;</span></span>),
    squares(Squares.INSTANCE, <span class="string"><span class="delimiter">&quot;</span><span class="content">2 ‚ãÖ 9</span><span class="delimiter">&quot;</span></span>),

    klein(KleinGroup.INSTANCE,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">a * b * c * e</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">a * b</span><span class="delimiter">&quot;</span></span>
    ),
    quaterniongroup(QuaternionGroup.INSTANCE, <span class="string"><span class="delimiter">&quot;</span><span class="content">i</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span> ),
    dihedral3(DihedralGroup.D3,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">r1 * r2</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">s0 * r1 * s0</span><span class="delimiter">&quot;</span></span>
    ),
    dihedral4(DihedralGroup.of(<span class="integer">4</span>),
        <span class="string"><span class="delimiter">&quot;</span><span class="content">r1 * r2</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">s0 * r1 * s0 * s3</span><span class="delimiter">&quot;</span></span>
    )
    ;

    <span class="directive">private</span> <span class="directive">final</span> Magma&lt;?&gt; field;
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> examples;
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> elements;
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> binaryOperators;
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> unaryOperators;

    <span class="directive">private</span> <span class="directive">final</span> <span class="type">boolean</span> finite;

    FieldInformation(Magma&lt;?&gt; field, <span class="predefined-type">String</span>... examples) {
        <span class="local-variable">this</span>.field = field;
        <span class="local-variable">this</span>.finite = field.isFinite();
        <span class="local-variable">this</span>.examples = examples;
        <span class="local-variable">this</span>.elements = elements(field);
        <span class="local-variable">this</span>.binaryOperators = field.getSupportedOperators()
            .stream()
            .map(AlgebraicBinaryOperator::getSymbol)
            .toArray(<span class="predefined-type">String</span><span class="type">[]</span>::<span class="keyword">new</span>);

        <span class="local-variable">this</span>.unaryOperators = field.getSupportedUnaryOperators()
            .stream()
            .map(AlgebraicUnaryOperator::getSymbol)
            .toArray(<span class="predefined-type">String</span><span class="type">[]</span>::<span class="keyword">new</span>);

        log.fine(<span class="string"><span class="delimiter">&quot;</span><span class="content">Created %s, operators: %s, unary: %s examples: %s, elements: %s</span><span class="delimiter">&quot;</span></span>.formatted(field,
            <span class="predefined-type">List</span>.of(binaryOperators),
            <span class="predefined-type">List</span>.of(unaryOperators),
            <span class="predefined-type">List</span>.of(examples), <span class="predefined-type">List</span>.of(elements)));
    }

    <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span><span class="type">[]</span> elements(Magma&lt;?&gt; field) {
        <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; elements = <span class="keyword">new</span> <span class="predefined-type">LinkedHashSet</span>&lt;&gt;(field.getConstants().keySet());
        <span class="keyword">if</span> (field.getCardinality().isCountable() &amp;&amp; field <span class="keyword">instanceof</span>  Streamable&lt;?&gt; streamable) {
            streamable.stream().limit(<span class="integer">100</span>).map(<span class="predefined-type">Object</span>::toString).forEach(elements::add);
        }
        <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> <span class="predefined-type">String</span>[<span class="integer">0</span>]);
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> getDescription() {
        <span class="keyword">return</span> field.getClass().getSimpleName() + <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span> + field;
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> getHelp() {
        <span class="keyword">return</span> field.getDescription().orElse(<span class="predefined-constant">null</span>);
    }
}



<span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> eval(<span class="directive">final</span> <span class="predefined-type">String</span> expression, <span class="directive">final</span> <span class="predefined-type">String</span> field) {
    <span class="keyword">try</span> (<span class="type">var</span> r = ConfigurationService.setConfiguration(cb -&gt; cb
        .configure(UncertaintyConfiguration.class,
            (ub) -&gt; ub.withNotation(ROUND_VALUE))
        .configure(MathContextConfiguration.class,
            (mc) -&gt; mc.withContext(<span class="keyword">new</span> <span class="predefined-type">MathContext</span>(Utils.PI.length())))
    )) {
        <span class="type">var</span> f = FieldInformation.valueOf(field).getField();

        log.fine(() -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Evaluating expression in %s: %s. Binary: %s, Unary: %s</span><span class="delimiter">&quot;</span></span>.formatted(f, expression, f.getSupportedOperators(), f.getSupportedUnaryOperators()));
        <span class="keyword">if</span> (f.getSupportedOperators().isEmpty()) {
            log.log(<span class="predefined-type">Level</span>.SEVERE,  <span class="string"><span class="delimiter">&quot;</span><span class="content">Supported operators is empty for </span><span class="delimiter">&quot;</span></span> + f);
        }
        <span class="type">var</span> parsedExpression = AST.parse(expression, f);
        log.fine(() -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Parsed expression: %s</span><span class="delimiter">&quot;</span></span>.formatted( parsedExpression));
        <span class="type">var</span> result = parsedExpression.eval();
        <span class="type">var</span> resultAsString = result.toString();
        log.info(() -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: %s = %s</span><span class="delimiter">&quot;</span></span>.formatted(expression, resultAsString));
        <span class="keyword">return</span> resultAsString;
    } <span class="keyword">catch</span> (<span class="predefined-type">Throwable</span> ex) {
        log.log(<span class="predefined-type">Level</span>.SEVERE,  ex.getClass() + <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span> + ex.getMessage(), ex);
        <span class="keyword">throw</span> ex;
    } <span class="keyword">finally</span> {
        log.finer(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ready evaluation</span><span class="delimiter">&quot;</span></span>);
    }
}</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">javascript</summary>
<div class="content">
<div class="paragraph">
<p>This is the source code for the above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">    constructor() {
        <span class="reserved">super</span>(<span class="string"><span class="delimiter">'</span><span class="content">#calculator</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">org.meeuw.math.demo.Calculator</span><span class="delimiter">'</span></span>);
        <span class="local-variable">this</span>.input = <span class="local-variable">this</span>.form.querySelector(<span class="string"><span class="delimiter">'</span><span class="content">input</span><span class="delimiter">'</span></span>);
        <span class="local-variable">this</span>.field = <span class="local-variable">this</span>.form.querySelector(<span class="string"><span class="delimiter">'</span><span class="content">select</span><span class="delimiter">'</span></span>);
        <span class="local-variable">this</span>.inputDataList= <span class="local-variable">this</span>.form.querySelector(<span class="string"><span class="delimiter">'</span><span class="content">datalist</span><span class="delimiter">'</span></span>);
        <span class="local-variable">this</span>.information = <span class="predefined-constant">null</span>;
    }

    insert(string) {
        const input = <span class="local-variable">this</span>.input;
        const start = input.selectionStart;
        const end = input.selectionEnd;
        const value = input.value;
        input.value = value.slice(<span class="integer">0</span>, start) + string + value.slice(end);
        input.setSelectionRange(
            start + string.length,
            start + string.length
        );
        input.focus();
    }

    insertOperator(string) {
        const needsBrackets = string.length &gt; <span class="integer">1</span>;
        <span class="keyword">if</span> (! needsBrackets) {
            <span class="keyword">return</span> <span class="local-variable">this</span>.insert(string);
        }
        const input = <span class="local-variable">this</span>.input;
        const start = input.selectionStart;
        const end = input.selectionEnd;
        const value = input.value;
        <span class="keyword">if</span> (start === end) {
            input.value = string + <span class="string"><span class="delimiter">&quot;</span><span class="content">(</span><span class="delimiter">&quot;</span></span> + value + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>;
            input.setSelectionRange(
                start + string.length + <span class="integer">1</span>,
                start + string.length + <span class="integer">1</span>
            );
        } <span class="keyword">else</span> {
            input.value = value.slice(<span class="integer">0</span>, start) + string + <span class="string"><span class="delimiter">&quot;</span><span class="content">(</span><span class="delimiter">&quot;</span></span> + value.slice(start, end) + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span> + value.slice(end);
            input.setSelectionRange(
                start,
                end  + string.length + <span class="integer">2</span>
            );
        }

        input.focus();
    }

    async setupForm() {
        await <span class="reserved">super</span>.setupForm();
        <span class="local-variable">this</span>.form.addEventListener(<span class="string"><span class="delimiter">'</span><span class="content">beforeinput</span><span class="delimiter">'</span></span>, async (e) =&gt; {
            <span class="local-variable">this</span>.form.querySelector(<span class="string"><span class="delimiter">&quot;</span><span class="content">span.help</span><span class="delimiter">&quot;</span></span>).innerHTML = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;
            <span class="keyword">if</span> (e.data === <span class="string"><span class="delimiter">'</span><span class="content">=</span><span class="delimiter">'</span></span>) {
                console.log(<span class="local-variable">this</span>.input.value);
                e.preventDefault();
                e.stopImmediatePropagation();
                await <span class="local-variable">this</span>.handleSubmit();
            }
             <span class="keyword">if</span> (e.data === <span class="string"><span class="delimiter">'</span><span class="content">*</span><span class="delimiter">'</span></span>) {
                 <span class="local-variable">this</span>.form.querySelector(<span class="string"><span class="delimiter">&quot;</span><span class="content">span.help</span><span class="delimiter">&quot;</span></span>).innerHTML = <span class="string"><span class="delimiter">&quot;</span><span class="content">to type * use ;</span><span class="delimiter">&quot;</span></span>;
                 e.preventDefault();
                 e.stopImmediatePropagation();
                 <span class="local-variable">this</span>.insert(<span class="string"><span class="delimiter">'</span><span class="content">‚ãÖ</span><span class="delimiter">'</span></span>)
             }
            <span class="keyword">if</span> (e.data === <span class="string"><span class="delimiter">'</span><span class="content">;</span><span class="delimiter">'</span></span>) {
                 e.preventDefault();
                 e.stopImmediatePropagation();
                 <span class="local-variable">this</span>.insert(<span class="string"><span class="delimiter">'</span><span class="content">*</span><span class="delimiter">'</span></span>)
             }
        });
    }

    async onInView(Calculator){

        await <span class="reserved">super</span>.onInView(Calculator);
        <span class="comment">// using the field information to update the example per field</span>
        <span class="keyword">if</span> (<span class="local-variable">this</span>.information === <span class="predefined-constant">null</span>) {
            <span class="local-variable">this</span>.information = {};
            const fi = await (await BaseClass.cj)[<span class="string"><span class="delimiter">'</span><span class="content">org.meeuw.math.demo.Calculator$FieldInformation</span><span class="delimiter">'</span></span>];
            const values = await fi.values();

            <span class="keyword">for</span> (let i = <span class="integer">0</span>; i &lt; values.length; i++) {
                const value = await values[i];
                const elements = await BaseClass.awaitedArray(value.getElements());
                let elementSpans = <span class="predefined-constant">null</span>;
                <span class="keyword">if</span> (elements) {
                    elementSpans = [];
                    <span class="keyword">for</span> (let j = <span class="integer">0</span>; j &lt; elements.length; j++) {
                        const span = document.createElement(<span class="string"><span class="delimiter">'</span><span class="content">span</span><span class="delimiter">'</span></span>);
                        span.classList.add(<span class="string"><span class="delimiter">'</span><span class="content">element</span><span class="delimiter">'</span></span>);
                        span.textContent = elements[j];
                        span.onclick = async e =&gt; {
                            <span class="local-variable">this</span>.insert(e.target.textContent);
                        };
                        elementSpans[j] = span;
                    }
                }
                <span class="local-variable">this</span>.information[await values[i].name()] = {
                    <span class="key">examples</span>: await BaseClass.awaitedArray(value.getExamples()),
                    <span class="key">elements</span>: elements,
                    <span class="key">elementsSpans</span>: elementSpans,
                    <span class="key">binaryOperators</span>: await BaseClass.awaitedArray(value.getBinaryOperators()),
                    <span class="key">unaryOperators</span>: await BaseClass.awaitedArray(value.getUnaryOperators()),
                    <span class="key">finite</span>: await value.isFinite(),
                    <span class="key">description</span>: await value.getDescription(),
                    <span class="key">help</span>: await value.getHelp()
                };
            }
            console.log(JSON.stringify(<span class="local-variable">this</span>.information));
        }
        await <span class="local-variable">this</span>.updateFieldList();
        <span class="local-variable">this</span>.field.addEventListener(<span class="string"><span class="delimiter">'</span><span class="content">change</span><span class="delimiter">'</span></span>, () =&gt; {
            <span class="local-variable">this</span>.updateDataList();
            <span class="local-variable">this</span>.updateHelp();
            <span class="local-variable">this</span>.updateOperators();
            <span class="local-variable">this</span>.updateDigits();

        });
        await <span class="local-variable">this</span>.updateDataList();
        await <span class="local-variable">this</span>.updateHelp();
        await <span class="local-variable">this</span>.updateOperators();
        await <span class="local-variable">this</span>.updateDigits();


    }

    updateFieldList() {
        <span class="keyword">for</span> (const [key, value] of Object.entries(<span class="local-variable">this</span>.information)) {

            const option = document.createElement(<span class="string"><span class="delimiter">'</span><span class="content">option</span><span class="delimiter">'</span></span>);
            option.value = key;
            option.text = value.description;
            <span class="local-variable">this</span>.field.appendChild(option);
        }
    }

    async updateDataList() {
        const selectedField = <span class="local-variable">this</span>.field.value;
        const information = <span class="local-variable">this</span>.information[selectedField];
        <span class="keyword">if</span> (information) {
            <span class="local-variable">this</span>.inputDataList.innerHTML = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;
            <span class="keyword">for</span> (const example of information.examples) {
                const option = document.createElement(<span class="string"><span class="delimiter">'</span><span class="content">option</span><span class="delimiter">'</span></span>);
                option.value = example;
                <span class="local-variable">this</span>.inputDataList.appendChild(option);
            }
            console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Updated data list for</span><span class="delimiter">&quot;</span></span>, selectedField, information.examples);
        }
    }
    async updateHelp() {
        const fieldInformation =  <span class="local-variable">this</span>.information[<span class="local-variable">this</span>.field.value];
        const div = <span class="local-variable">this</span>.field.parentNode.querySelector(<span class="string"><span class="delimiter">&quot;</span><span class="content">div.help</span><span class="delimiter">&quot;</span></span>);
        div.innerHTML = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;
        let help = fieldInformation.help;
        <span class="keyword">if</span> (help) {
            div.appendChild(document.createTextNode(help));
        }
        const elements = <span class="local-variable">this</span>.information[<span class="local-variable">this</span>.field.value].elementSpans;
        <span class="keyword">if</span> (elements) {
            div.appendChild(document.createElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">br</span><span class="delimiter">&quot;</span></span>));
            div.appendChild(document.createTextNode(<span class="string"><span class="delimiter">&quot;</span><span class="content">elements: </span><span class="delimiter">&quot;</span></span>));
            elements.forEach(element =&gt; {
                div.appendChild(element);
            })
            <span class="keyword">if</span> (!fieldInformation.finite) {
                div.appendChild(document.createTextNode(<span class="string"><span class="delimiter">&quot;</span><span class="content">... infinitely many more</span><span class="delimiter">&quot;</span></span>));
            }
        }
    }
    operatorDts(dl, operators) {
        <span class="local-variable">this</span>.dts(dl, operators, async e =&gt; {
            <span class="local-variable">this</span>.insertOperator(e.target.textContent);
        });
    }
    elementsDts(dl, operators) {
        <span class="local-variable">this</span>.dts(dl, operators, async e =&gt; {
            <span class="local-variable">this</span>.insert(e.target.textContent);
        });
    }

    dts(dl, operators, onclick) {
        const list = dl.querySelectorAll(<span class="string"><span class="delimiter">&quot;</span><span class="content">dt</span><span class="delimiter">&quot;</span></span>);
        const symbolsInList = Array.from(list).map(e =&gt; e.textContent.trim());
        const unmatchedOperators = operators.filter(op =&gt; !symbolsInList.includes(op));
        unmatchedOperators.forEach(op =&gt; {
            const dt = document.createElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">dt</span><span class="delimiter">&quot;</span></span>);
            dt.classList.add(<span class="string"><span class="delimiter">'</span><span class="content">hdlist1</span><span class="delimiter">'</span></span>);
            dt.textContent = op;
            dl.appendChild(dt);
            const dd = document.createElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">dd</span><span class="delimiter">&quot;</span></span>);
            dl.appendChild(dd);
        });
        <span class="keyword">for</span> (const e of dl.querySelectorAll(<span class="string"><span class="delimiter">&quot;</span><span class="content">dt</span><span class="delimiter">&quot;</span></span>)) {
            const symbol = e.textContent.trim();
            const title = e.nextElementSibling.textContent;
            <span class="keyword">if</span> (!e.hasAttribute(<span class="string"><span class="delimiter">&quot;</span><span class="content">original-display</span><span class="delimiter">&quot;</span></span>)) {
                e.setAttribute(<span class="string"><span class="delimiter">&quot;</span><span class="content">original-display</span><span class="delimiter">&quot;</span></span>, window.getComputedStyle(e).display);
                e.onclick =onclick;
            }
            <span class="keyword">if</span> (!operators.includes(symbol)) {
                e.style.display = <span class="string"><span class="delimiter">'</span><span class="content">none</span><span class="delimiter">'</span></span>;
                e.nextElementSibling.hidden = <span class="predefined-constant">true</span>;
            } <span class="keyword">else</span> {
                e.title = title;
                e.style.display = e.getAttribute(<span class="string"><span class="delimiter">&quot;</span><span class="content">original-display</span><span class="delimiter">&quot;</span></span>);
                e.nextElementSibling.hidden = <span class="predefined-constant">false</span>;
            }
        }
    }

    async updateOperators() {
        const fieldInformation =  <span class="local-variable">this</span>.information[<span class="local-variable">this</span>.field.value];
        const operators = fieldInformation.binaryOperators;
        <span class="local-variable">this</span>.operatorDts(document.querySelector(<span class="string"><span class="delimiter">&quot;</span><span class="content">#calculator_operators dl</span><span class="delimiter">&quot;</span></span>), operators);
        const unaryOperators = fieldInformation.unaryOperators;
        <span class="local-variable">this</span>.operatorDts(document.querySelector(<span class="string"><span class="delimiter">&quot;</span><span class="content">#calculator_unary_operator dl</span><span class="delimiter">&quot;</span></span>), unaryOperators);
    }


    async updateDigits() {
        const fieldInformation =  <span class="local-variable">this</span>.information[<span class="local-variable">this</span>.field.value];
        const elements = fieldInformation.elements;
        <span class="local-variable">this</span>.elementsDts(document.querySelector(<span class="string"><span class="delimiter">&quot;</span><span class="content">#calculator_digits dl</span><span class="delimiter">&quot;</span></span>), elements);
    }

    async onSubmit(Calculator) {
        <span class="local-variable">this</span>.output.value = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;
        <span class="local-variable">this</span>.textContent = <span class="string"><span class="delimiter">&quot;</span><span class="content">executing..</span><span class="delimiter">&quot;</span></span>;
        <span class="comment">//console.log(&quot;evaluating&quot;, this.input.value, &quot;for&quot;, this.field.value);</span>
        <span class="local-variable">this</span>.output.value = await Calculator.eval(
            <span class="local-variable">this</span>.input.value, <span class="local-variable">this</span>.field.value
        );
    }

}</code></pre>
</div>
</div>
</div>
</details>
</div>
</div>
<div class="sect1 tips-aside">
<h2 id="demo_solver">Solver</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The same idea as my <a href="https://meeuw.org/flippo/flippo.html">very first applet</a>. Solving the '24 flippo game'.</p>
</div>
<div class="paragraph">
<p>Give the desired outcome number, and a few input numbers, and it will find the possible ways to get it using those input numbers.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>This combines several aspects of this project:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It uses 'rational numbers' to make all operations exact</p>
</li>
<li>
<p>It uses the permutation group to permute all combinations of values</p>
</li>
<li>
<p>It uses the Abstract Syntax Tree feature to combine values and operators</p>
</li>
<li>
<p>It uses some features of the Field, e.g. to perform operators generically.</p>
</li>
<li>
<p>It will currently use the field of <code>RationalNumbers</code> <em>or</em> <code>GaussianRationals</code> if the input contains a complex number. I might add also suport for <code>RealField</code> (and for example also support the POW operator)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cheerpj still sometimes behaves a bit erraticly, I think something may be wrong with default methods?</p>
</div>
</td>
</tr>
</table>
</div>
<form id="solver" class="demo">
  <label for="solver_outcome">Desired outcome:</label>
  <input type="text"
         required="required"
         id="solver_outcome"  list="solver_outcome-examples"
         data-parser="parseOutcome"
         data-error-message="enter one (fractional) number"
         value="24"/>
  <datalist id="solver_outcome-examples">
     <option value="24">the original 24 game value</option>
     <option value="4 1/3">fractions are allowed</option>
     <option value="41"></option>
     <option value="120">a nicer value for 5 input numbers</option>
   </datalist>
   <br />
  <label for="solver_input">Input numbers:</label>
  <input type="text" id="solver_input"
         list="solver_input-examples"
         required="required"
         placeholder="Enter a few numbers (probably no more than 5)"
          data-parser="parseInput"
          data-error-message="enter one or more (fractional) numbers"
         />
   <datalist id="solver_input-examples">
     <option value="8 8 3 3">a hard one to make 24 with</option>
     <option value="4 7 7 7 8" >a hard one to make 120 with</option>

   </datalist>
  <br />
  <output id="solver_output"  for="solver_result solver_numbers"> </output>
  <br />
  <button name="submit">go!</button>
</form>
<details>
<summary class="title">java source code</summary>
<div class="content">
<div class="paragraph">
<p>This is the source code for the above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.meeuw.math.demo</span>;

<span class="keyword">import</span> <span class="include">lombok.Getter</span>;
<span class="keyword">import</span> <span class="include">lombok.extern.java.Log</span>;

<span class="keyword">import</span> <span class="include">java.util</span>.*;
<span class="keyword">import</span> <span class="include">java.util.concurrent.atomic.AtomicLong</span>;
<span class="keyword">import</span> <span class="include">java.util.stream.Stream</span>;

<span class="keyword">import</span> <span class="include">org.meeuw.math.abstractalgebra.Ring</span>;
<span class="keyword">import</span> <span class="include">org.meeuw.math.abstractalgebra.RingElement</span>;
<span class="keyword">import</span> <span class="include">org.meeuw.math.abstractalgebra.complex.GaussianRationals</span>;
<span class="keyword">import</span> <span class="include">org.meeuw.math.abstractalgebra.permutations.PermutationGroup</span>;
<span class="keyword">import</span> <span class="include">org.meeuw.math.abstractalgebra.quaternions.Quaternions</span>;
<span class="keyword">import</span> <span class="include">org.meeuw.math.abstractalgebra.rationalnumbers.RationalNumbers</span>;
<span class="keyword">import</span> <span class="include">org.meeuw.math.arithmetic.ast</span>.*;
<span class="keyword">import</span> <span class="include">org.meeuw.math.exceptions.MathException</span>;
<span class="keyword">import</span> <span class="include">org.meeuw.math.exceptions.NotParsable</span>;
<span class="keyword">import</span> <span class="include">org.meeuw.math.operators.AlgebraicBinaryOperator</span>;

<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.meeuw.math.CollectionUtils.navigableSet</span>;
<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.meeuw.math.operators.BasicAlgebraicBinaryOperator</span>.*;

<span class="comment">/**
 * A tool to evaluate all possible expressions (of a certain number of rational numbers) (and check if it equals a certain value)
 */</span>
<span class="annotation">@Log</span>
<span class="directive">public</span>  <span class="type">class</span> <span class="class">Solver</span>&lt;E <span class="directive">extends</span> RingElement&lt;E&gt;&gt; {
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> NavigableSet&lt;AlgebraicBinaryOperator&gt; OPERATORS = navigableSet(
        ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION
    );

    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">AtomicLong</span> tries = <span class="keyword">new</span> <span class="predefined-type">AtomicLong</span>();

    <span class="annotation">@Getter</span>
    <span class="directive">private</span> <span class="directive">final</span> Ring&lt;E&gt; structure;

    <span class="directive">public</span> Solver(Ring&lt;E&gt; structure) {
        <span class="local-variable">this</span>.structure = structure;
    }

    <span class="annotation">@SafeVarargs</span>
    <span class="directive">public</span> <span class="directive">final</span> Stream&lt;<span class="predefined-type">Expression</span>&lt;E&gt;&gt; stream(E... set) {
        PermutationGroup permutations = PermutationGroup.ofDegree(set.length);

        <span class="keyword">return</span> permutations.stream()
            .map(permutation -&gt; permutation.permute(set))
            .map(<span class="predefined-type">List</span>::of)
            .distinct()
            .flatMap(permuted -&gt;
                AST.stream(
                    permuted,
                    OPERATORS
                )
            )
            .map( e -&gt; e.canonize(structure))
            .distinct()
            .peek(e -&gt; tries.getAndIncrement());
    }



    <span class="directive">public</span> Stream&lt;EvaluatedExpression&lt;E&gt;&gt; evaledStream(E... set) {
        <span class="keyword">return</span> stream(set)
            .map(e -&gt; {
                <span class="keyword">try</span> {
                    E evaled = e.eval();
                    <span class="keyword">return</span> <span class="keyword">new</span> EvaluatedExpression&lt;&gt;(e, evaled);
                } <span class="keyword">catch</span> (MathException ex) {
                    <span class="keyword">return</span> <span class="predefined-constant">null</span>;
                }
            })
            .filter(Objects::nonNull);
    }

    <span class="comment">/**
     *
     */</span>
    <span class="directive">public</span>  <span class="directive">static</span> &lt;E <span class="directive">extends</span> RingElement&lt;E&gt;&gt; SolverResult solve(Ring&lt;E&gt; structure, <span class="predefined-type">String</span> outcomeString, <span class="predefined-type">String</span> inputStrings) {

        ParseResult&lt;E&gt; outcome = parseOutcome(structure, outcomeString);
        ParseResult&lt;E<span class="type">[]</span>&gt; input = parseInput(structure, inputStrings);
        <span class="keyword">if</span> (outcome.success() &amp;&amp; input.success()) {
            <span class="keyword">return</span> solve(structure, outcome.result(), input.result());
        } <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="keyword">new</span> NotParsable(outcome.error() + <span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span> + input.error());
        }
    }

    <span class="directive">public</span>  <span class="directive">static</span> &lt;E <span class="directive">extends</span> RingElement&lt;E&gt;&gt; SolverResult solve(Ring&lt;E&gt; structure, E outcome, E<span class="type">[]</span> input) {

        Solver&lt;E&gt; solver = <span class="keyword">new</span> Solver&lt;&gt;(structure);
        <span class="predefined-type">AtomicLong</span> matches = <span class="keyword">new</span> <span class="predefined-type">AtomicLong</span>();
        log.info(() -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Solving input </span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">List</span>.of(input) + <span class="string"><span class="delimiter">&quot;</span><span class="content"> for </span><span class="delimiter">&quot;</span></span> + outcome + <span class="string"><span class="delimiter">&quot;</span><span class="content"> ( in field </span><span class="delimiter">&quot;</span></span> + structure + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);

        <span class="keyword">return</span> <span class="keyword">new</span> SolverResult(solver.evaledStream(input)
            .filter(e -&gt;
                e.result().eq(outcome)
            ).peek(e -&gt; matches.getAndIncrement())
            .map(EvaluatedExpression::toString),
            solver.tries, matches, structure);
    }

    <span class="directive">public</span> <span class="directive">static</span> &lt;F <span class="directive">extends</span> RingElement&lt;F&gt;&gt; ParseResult&lt;F&gt; parseOutcome(Ring&lt;F&gt; field, <span class="predefined-type">String</span> outcomeString) {
        log.info(() -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Parsing input </span><span class="delimiter">&quot;</span></span> + outcomeString + <span class="string"><span class="delimiter">&quot;</span><span class="content"> in field </span><span class="delimiter">&quot;</span></span> + field);

        <span class="predefined-type">String</span> resultError = <span class="predefined-constant">null</span>;
        F result;
        <span class="keyword">try</span> {
            result = field.fromString(outcomeString);
        } <span class="keyword">catch</span> (NotParsable pe) {
            result = <span class="predefined-constant">null</span>;
            resultError = pe.getMessage();
        }
        <span class="keyword">return</span> <span class="keyword">new</span> ParseResult&lt;F&gt;(outcomeString, result, resultError);
    }
    <span class="directive">public</span> <span class="directive">static</span> &lt;F <span class="directive">extends</span> RingElement&lt;F&gt;&gt; ParseResult&lt;F<span class="type">[]</span>&gt; parseInput(Ring&lt;F&gt; field, <span class="predefined-type">String</span> inputStrings) {
        log.info(() -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Parsing input </span><span class="delimiter">&quot;</span></span> + inputStrings + <span class="string"><span class="delimiter">&quot;</span><span class="content"> in field </span><span class="delimiter">&quot;</span></span> + field);

        <span class="predefined-type">String</span> inputError = <span class="predefined-constant">null</span>;

        <span class="predefined-type">String</span><span class="type">[]</span> input = inputStrings.split(<span class="string"><span class="delimiter">&quot;</span><span class="char">\\</span><span class="content">s+</span><span class="delimiter">&quot;</span></span>);
        F<span class="type">[]</span> set = field.newArray(input.length);
        <span class="keyword">try</span> {
            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; set.length; i++) {
                set[i] = field.fromString(input[i]);
            }
        } <span class="keyword">catch</span> (NotParsable pe) {
            inputError = pe.getMessage();
        }
        <span class="keyword">return</span> <span class="keyword">new</span> ParseResult&lt;&gt;(inputStrings, set, inputError);
    }

    <span class="directive">public</span> <span class="directive">static</span> Ring&lt;?&gt; algebraicStructureFor(<span class="predefined-type">String</span> outcomeString, <span class="predefined-type">String</span> input) {
        log.info(() -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Determining algebraic structure for outcome </span><span class="delimiter">&quot;</span></span> + outcomeString + <span class="string"><span class="delimiter">&quot;</span><span class="content"> and input </span><span class="delimiter">&quot;</span></span> + input);
        <span class="keyword">if</span> (outcomeString.matches(<span class="string"><span class="delimiter">&quot;</span><span class="content">.*[jk].*</span><span class="delimiter">&quot;</span></span>) || input.matches(<span class="string"><span class="delimiter">&quot;</span><span class="content">.*[jk].*</span><span class="delimiter">&quot;</span></span>)) {
            <span class="keyword">return</span> Quaternions.of(RationalNumbers.INSTANCE);
        } <span class="keyword">else</span> <span class="keyword">if</span> (outcomeString.contains(<span class="string"><span class="delimiter">&quot;</span><span class="content">i</span><span class="delimiter">&quot;</span></span>) || input.contains(<span class="string"><span class="delimiter">&quot;</span><span class="content">i</span><span class="delimiter">&quot;</span></span>)) {
            <span class="keyword">return</span> GaussianRationals.INSTANCE;
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> RationalNumbers.INSTANCE;
        }
    }


    <span class="directive">public</span> record SolverResult(Stream&lt;<span class="predefined-type">String</span>&gt; stream, <span class="predefined-type">AtomicLong</span> tries, <span class="predefined-type">AtomicLong</span> matches, Ring&lt;?&gt; field) {


    }

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> integers) {
        <span class="keyword">if</span> (integers.length &lt; <span class="integer">3</span>) {
            <span class="predefined-type">System</span>.out.println();
            <span class="predefined-type">System</span>.exit(<span class="integer">1</span>);
        }
        <span class="predefined-type">String</span> resultString = integers[<span class="integer">0</span>];
        <span class="predefined-type">String</span> inputStrings = <span class="predefined-type">String</span>.join(<span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">Arrays</span>.copyOfRange(integers, <span class="integer">1</span>, integers.length));

        Ring&lt;?&gt; field = algebraicStructureFor(resultString, inputStrings);
        SolverResult solverResult = Solver.solve(field, resultString, inputStrings);
        solverResult.stream().forEach(<span class="predefined-type">System</span>.out::println);
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">ready, found </span><span class="delimiter">&quot;</span></span> + solverResult.matches().get() + <span class="string"><span class="delimiter">&quot;</span><span class="content">, tried </span><span class="delimiter">&quot;</span></span> + solverResult.tries.get() + <span class="string"><span class="delimiter">&quot;</span><span class="content">, field </span><span class="delimiter">&quot;</span></span> + solverResult.field().toString());
    }
}</code></pre>
</div>
</div>
</div>
</details>
<details>
<summary class="title">javascript</summary>
<div class="content">
<div class="paragraph">
<p>This is the source code for the above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">    async onSubmit(Solver) {
        <span class="local-variable">this</span>.output.value += <span class="string"><span class="delimiter">&quot;</span><span class="content">using: </span><span class="delimiter">&quot;</span></span> + await (<span class="local-variable">this</span>.model.field).toString();
        const solverResult = await Solver.solve(
            <span class="local-variable">this</span>.model.field, <span class="local-variable">this</span>.outcome.value, <span class="local-variable">this</span>.input.value
            );

        const stream = await solverResult.stream();
        const lines = await stream.toArray();
        <span class="keyword">for</span> (let i = <span class="integer">0</span>; i &lt; lines.length; i++) {
            <span class="local-variable">this</span>.output.value += <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span> + await lines[i].toString();
        }
        const tries = await (await solverResult.tries()).get();
        const matches = await (await solverResult.matches()).get();
        <span class="local-variable">this</span>.output.value += <span class="error">`</span><span class="error">\</span>nFound: <span class="predefined">$</span>{matches}<span class="error">`</span>;
        <span class="local-variable">this</span>.output.value += <span class="error">`</span><span class="error">\</span>nTried: <span class="predefined">$</span>{tries}<span class="error">`</span>;
    }
}</code></pre>
</div>
</div>
</div>
</details>
</div>
</div>
<div class="sect1">
<h2 id="demo_dynamicdate">Dynamic date parsing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>mihxil-time</code> module contain a 'dynamic date parser. I dusted this of from old <a href="mmbase.org">mmbase</a> code.</p>
</div>
<form id="dynamicdate" class="demo">
  <label for="dynamicdate_toparse">String to parse:</label> <input type="text" id="dynamicdate_toparse"  list="dynamicdate_toparse-examples" value="" />
   <datalist id="dynamicdate_toparse-examples">
    <option value="0"></option>
    <option value="10000"></option>
    <option value="-10000"></option>
    <option value="+1000"></option>
    <option value="1973-05-03"></option>
    <option value="2006-05-09"></option>
    <option value="-3-12-25"></option>
    <option value="2000-01-01 16:00"></option>
    <option value="TZUTC 2001-01-01 16:00"></option>
    <option value="today 12:34:56.789"></option>
    <option value="now"></option>
    <option value="today"></option>
    <option value="tomorrow"></option>
    <option value="now + 10 minute"></option>
    <option value="today + 5 day"></option>
    <option value="now this year"></option>
    <option value="next august"></option>
    <option value="today + 6 month next august"></option>
    <option value="tomonth"></option>
    <option value="borreltijd"></option>
    <option value="today + 5 dayish"></option>
    <option value="yesteryear"></option>
    <option value="mondayish"></option>
    <option value="duration + 5 minute"></option>
    <option value="duration + 100 year"></option>
    <option value="TZUTC today noon"></option>
    <option value="TZEurope/Amsterdam today noon"></option>
    <option value="TZUTC today"></option>
    <option value="TZEurope/Amsterdam today"></option>
    <option value="TZ UTC today noon"></option>
    <option value="TZ Europe/Amsterdam today noon"></option>
    <option value="TZ UTC today"></option>
    <option value="TZ Europe/Amsterdam today"></option>
    <option value="TZ Europe/Amsterdam -1000"></option>
    <option value="today 6 oclock"></option>
    <option value="today 23 oclock"></option>
    <option value="today 43 oclock"></option>
    <option value="tosecond"></option>
    <option value="tominute"></option>
    <option value="tohour"></option>
    <option value="today"></option>
    <option value="previous monday"></option>
    <option value="tomonth"></option>
    <option value="toyear"></option>
    <option value="tocentury"></option>
    <option value="tocentury_pedantic"></option>
    <option value="toera"></option>
    <option value="toweek"></option>
    <option value="now this second"></option>
    <option value="now this minute"></option>
    <option value="now this hour"></option>
    <option value="now this day"></option>
    <option value="today previous monday"></option>
    <option value="now this month"></option>
    <option value="now this year"></option>
    <option value="now this century"></option>
    <option value="now this era"></option>
    <option value="now - 15 year this century"></option>
    <option value="now - 20 year this century_pedantic"></option>
    <option value="today + 2 century"></option>
    <option value="toera - 1 minute"></option>
    <option value="this july"></option>
    <option value="previous july"></option>
    <option value="next july"></option>
    <option value="this sunday"></option>
    <option value="previous sunday"></option>
    <option value="next sunday"></option>
    <option value="2009-W01-01"></option>
    <option value="2009-W53-7"></option>
    <option value="2006-123"></option>
    <option value="2005-01-01 this monday"></option>
    <option value="next year"></option>
    <option value="&quot;spring&quot;"></option>
    <option value="next year &quot;spring&quot;"></option>
    <option value="&quot;easter sunday&quot;"></option>
   </datalist>
   <br />
  <output id="dynamicdate_output" for="dynamicdate_toparse"> </output>
  <br />
  <button name="submit">go!</button>
</form>
<details>
<summary class="title">javascript</summary>
<div class="content">
<div class="paragraph">
<p>This is the source code for the above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">async onSubmit(DynamicDateTime){
    <span class="keyword">try</span> {
        const parser = await <span class="keyword">new</span> DynamicDateTime();
        const parseResult = await parser.applyWithException(<span class="local-variable">this</span>.form.querySelector(<span class="string"><span class="delimiter">&quot;</span><span class="content">#dynamicdate_toparse</span><span class="delimiter">&quot;</span></span>).value);
        <span class="local-variable">this</span>.output.value = await parseResult.toString();
    } <span class="keyword">catch</span> (error) {
        console.log(error);
    }

}</code></pre>
</div>
</div>
</div>
</details>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-09-10 18:36:51 UTC
</div>
</div>
</body>
</html>