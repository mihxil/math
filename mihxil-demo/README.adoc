// DO NOT EDIT THIS FILE IT IS GENERATED!!
[#demo_section]
= Demo
:docinfo: private
:source-highlighter: coderay
:toc:

These are a running link:https://webassembly.org/[webassembly] demos (using link:https://cheerpj.com/docs/getting-started/Java-library[cheerpj]).


[NOTE]
====
This section is work in progress
====

:leveloffset: 1

[#demo_calculator]
[.tips-aside]
= Calculator


[TIP]
====
Expressions can be typed using the following operators:

[#calculator_operators]
+:: for addition
-:: for subtraction
‚ãÖ:: for multiplication (can be typed by '*')
/:: for division
*:: for the default 'group operation' (type ';'), for many groups this is the same as multiplication

Furthermore, constants of the field are recognized. Like 'pi' or 'i'.

Elements of the field are simply recognized if they are numeric, otherwise they may be quoted. E.g. an element of the complex field may be given as "3+4i". If they are simple strings like 'r3' they can also be matched as a constant of the field.

====

++++
<form id="calculator" class="demo">
  <label for="calculator_toparse">Expression to evaluate: <span class="help"></span></label> <input type="text" id="calculator_toparse"  list="calculator_toparse-examples" value="" />
   <datalist id="calculator_toparse-examples">
   <!-- filled by calculator.js -->
   </datalist>
   <label for="calculator_field">Field:</label>
   <select id="calculator_field"  >
   <!-- filled by calculator.js -->
   </select>
   <div class="help"></div>
   <br />
  <output id="calculator_output" for="calculator_toparse"> </output>
  <br />
  <button name="submit">go!</button>
</form>
++++

[%collapsible, title=java]
====
This is the source code for the above.
[source,java]
----

@Getter
public  enum FieldInformation {
    rational(RationalNumbers.INSTANCE, "1 + 2", "1 + 3/5"),
    real(RealField.INSTANCE, "1 + 2", "1 + 3/5", "sin(ùúã/2)"),
    bigdecimal(BigDecimalField.INSTANCE, "1 + 2", "1 + 3/5", "sin(ùúã/2)"),
    gaussian(GaussianRationals.INSTANCE, "1 + 2", "1 + 3/5", "\"1 + 2i\" ‚ãÖ 8i"),
    complex(ComplexNumbers.INSTANCE, "1 + 2", "1 + 3/5", "sin(ùúã/2)", "exp(-i ‚ãÖ ùúã)", "\"2 + 3i\" ‚ãÖ i"),
    bigcomplex(BigComplexNumbers.INSTANCE, "1 + 2", "1 + 3/5", "\"1 + 2i\" ‚ãÖ 8i"),
    quaternions(Quaternions.of(RationalNumbers.INSTANCE),
        "1 + 2", "1 + 3/5", "\"1 + 2i + 3j + 4k\" ‚ãÖ 8i"),
    quaternions_bigdecimal(Quaternions.of(BigDecimalField.INSTANCE),
        "1 + 2", "1 + 3/5", "\"1 + 2i + 3j + 4k\" ‚ãÖ 8i"),
    modulo10(ModuloRing.of(10), "4 ‚ãÖ 7", "9 - 3"),
    modulo13(ModuloField.of(13), "10 ‚ãÖ 7", "10 - 3", "12 ‚ãÖ 6 / 4"),
    klein(KleinGroup.INSTANCE,
        "a * b * c * e",
        "a * b"
    ),
    quaterniongroup(QuaternionGroup.INSTANCE, "i", "e" ),
    dihedral3(DihedralGroup.D3,
        "r1 * r2",
        "s0 * r1 * s0"
    ),
    dihedral4(DihedralGroup.of(4),
        "r1 * r2",
        "s0 * r1 * s0 * s3"
    )
    ;

    private final Magma<?> field;
    private final String[] examples;
    private final String[] elements;
    private final String[] binaryOperators;
    private final boolean finite;

    FieldInformation(Magma<?> field, String... examples) {
        this.field = field;
        this.finite = field.isFinite();
        this.examples = examples;
        this.elements = elements(field);
        this.binaryOperators = field.getSupportedOperators()
            .stream()
            .map(AlgebraicBinaryOperator::getSymbol)
            .toArray(String[]::new);

        log.info("Created %s, operators: %s, examples: %s, elements: %s".formatted(field,
            List.of(binaryOperators),
            List.of(examples), List.of(elements)));
    }

    public static String[] elements(Magma<?> field) {
        Set<String> elements = new LinkedHashSet<>(field.getConstants().keySet());
        if (field.getCardinality().isCountable() && field instanceof  Streamable<?> streamable) {
            streamable.stream().limit(100).map(Object::toString).forEach(elements::add);
        }
        return elements.toArray(new String[0]);
    }

    public String getDescription() {
        return field.getClass().getSimpleName() + " " + field;
    }

    public String getHelp() {
        return field.getDescription().orElse(null);
    }
}



public static String eval(final String expression, final String field) {
    try (var r = ConfigurationService.setConfiguration(cb -> cb
        .configure(UncertaintyConfiguration.class,
            (ub) -> ub.withNotation(ROUND_VALUE))
        .configure(MathContextConfiguration.class,
            (mc) -> mc.withContext(new MathContext(Utils.PI.length())))
    )) {
        var f = FieldInformation.valueOf(field).getField();

        log.info(() -> "Evaluating expression in %s: %s. Binary: %s, Unary: %s".formatted(f, expression, f.getSupportedOperators(), f.getSupportedUnaryOperators()));
        if (f.getSupportedOperators().isEmpty()) {
            log.log(Level.SEVERE,  "Supported operators is empty for " + f);
        }
        var parsedExpression = AST.parse(expression, f);
        log.info(() -> "Parsed expression: %s".formatted( parsedExpression));
        var result = parsedExpression.eval();
        var resultAsString = result.toString();
        log.info(() -> "Result: %s = %s".formatted(expression, resultAsString));
        return resultAsString;
    } catch (Throwable ex) {
        log.log(Level.SEVERE,  ex.getClass() + " " + ex.getMessage(), ex);
        throw ex;
    } finally {
        log.finer("Ready evaluation");
    }
}
----
====
[%collapsible, title=javascript]
====
This is the source code for the above.
[source,javascript]
----
    constructor() {
        super('#calculator', 'org.meeuw.math.demo.Calculator');
        this.input = this.form.querySelector('input');
        this.field = this.form.querySelector('select');
        this.inputDataList= this.form.querySelector('datalist');
        this.information = null;
    }

    insert(c) {
        const input = this.input;
        const start = input.selectionStart;
        const end = input.selectionEnd;
        const value = input.value;
        input.value = value.slice(0, start) + c + value.slice(end);
        input.setSelectionRange(start + 1, start + 1);
    }

    async setupForm() {
        await super.setupForm();
        this.form.addEventListener('beforeinput', async (e) => {
            this.form.querySelector("span.help").innerHTML = '';
            if (e.data === '=') {
                console.log(this.input.value);
                e.preventDefault();
                e.stopImmediatePropagation();
                await this.handleSubmit();
            }
             if (e.data === '*') {
                 this.form.querySelector("span.help").innerHTML = "to type * use ;";
                 e.preventDefault();
                 e.stopImmediatePropagation();
                 this.insert('‚ãÖ')
             }
            if (e.data === ';') {
                 e.preventDefault();
                 e.stopImmediatePropagation();
                 this.insert('*')
             }
        });
    }

    async onInView(Calculator){

        await super.onInView(Calculator);
        // using the field information to update the example per field
        if (this.information === null) {
            this.information = {};
            const fi = await (await BaseClass.cj)['org.meeuw.math.demo.Calculator$FieldInformation'];
            const values = await fi.values();

            for (let i = 0; i < values.length; i++) {
                const value = await values[i];
                const elements = await value.getElements();
                let awaitedElements = null;
                if (elements) {
                    awaitedElements = [];
                    for (let j = 0; j < elements.length; j++) {
                        const span = document.createElement('span');
                        span.classList.add('element');
                        span.textContent = await elements[j];
                        span.onclick = async e => {
                            console.log(e.target.textContent);
                            const input = this.input;
                            const start = input.selectionStart;
                            const end = input.selectionEnd;
                            const value = input.value;
                            const insertText = e.target.textContent;
                            input.value = value.slice(0, start) + insertText + value.slice(end);
                            input.setSelectionRange(start + insertText.length, start + insertText.length);
                            input.focus();
                        };
                        awaitedElements[j] = span;
                    }
                }
                this.information[await values[i].name()] = {
                    examples: await BaseClass.awaitedArray(value.getExamples()),
                    elements: awaitedElements,
                    binaryOperators: await BaseClass.awaitedArray(value.getBinaryOperators()),
                    finite: await value.isFinite(),
                    description: await value.getDescription(),
                    help: await value.getHelp()
                };
            }
            console.log(JSON.stringify(this.information));
        }
        await this.updateFieldList();
        this.field.addEventListener('change', () => {
            this.updateDataList();
            this.updateHelp();
            this.updateOperators();

        });
        await this.updateDataList();
        await this.updateHelp();
        await this.updateOperators();


    }

    updateFieldList() {
        for (const [key, value] of Object.entries(this.information)) {

            const option = document.createElement('option');
            option.value = key;
            option.text = value.description;
            this.field.appendChild(option);
        }
    }

    async updateDataList() {
        const selectedField = this.field.value;
        const information = this.information[selectedField];
        if (information) {
            this.inputDataList.innerHTML = '';
            for (const example of information.examples) {
                const option = document.createElement('option');
                option.value = example;
                this.inputDataList.appendChild(option);
            }
            console.log("Updated data list for", selectedField, information.examples);
        }
    }
    async updateHelp() {
        const fieldInformation =  this.information[this.field.value];
        const div = this.field.parentNode.querySelector("div.help");
        div.innerHTML = '';
        let help = fieldInformation.help;
        if (help) {
            div.appendChild(document.createTextNode(help));
        }
        const elements = this.information[this.field.value].elements;
        if (elements) {
            div.appendChild(document.createElement("br"));
            div.appendChild(document.createTextNode("elements: "));
            elements.forEach(element => {
                div.appendChild(element);
            })
            if (!fieldInformation.finite) {
                div.appendChild(document.createTextNode("... infinitely many more"));
            }
        }
    }
    async updateOperators() {
        const fieldInformation =  this.information[this.field.value];
        const operators = fieldInformation.binaryOperators;
        const dd = document.querySelector("#calculator_operators");
        dd.querySelectorAll("dt").forEach(e => {
            if (! operators.includes(e.textContent.trim())) {
                e.hidden = true;
                e.nextElementSibling.hidden = true;
            } else {
                e.hidden = false;
                e.nextElementSibling.hidden = false;
            }
        });
    }

    async onSubmit(Calculator) {
        this.output.value = '';
        this.textContent = "executing..";
        //console.log("evaluating", this.input.value, "for", this.field.value);
        this.output.value = await Calculator.eval(
            this.input.value, this.field.value
        );
    }

}
----
====

:leveloffset!:

:leveloffset: 1

[#demo_solver]
[.tips-aside]
= Solver

The same idea as my link:https://meeuw.org/flippo/flippo.html[very first applet]. Solving the '24 flippo game'.

Give the desired outcome number, and a few input numbers, and it will find the possible ways to get it using those input numbers.

[TIP]
====
This combines several aspects of this project:

- It uses 'rational numbers' to make all operations exact
- It uses the permutation group to permute all combinations of values
- It uses the Abstract Syntax Tree feature to combine values and operators
- It uses some features of the Field, e.g. to perform operators generically.
- It will currently use the field of `RationalNumbers` _or_ `GaussianRationals` if the input contains a complex number. I might add also suport for `RealField` (and for example also support the POW operator)

Cheerpj still sometimes behaves a bit erraticly, I think something may be wrong with default methods?
====

++++
<form id="solver" class="demo">
  <label for="solver_outcome">Desired outcome:</label>
  <input type="text"
         required="required"
         id="solver_outcome"  list="solver_outcome-examples"
         data-parser="parseOutcome"
         data-error-message="enter one (fractional) number"
         value="24"/>
  <datalist id="solver_outcome-examples">
     <option value="24">the original 24 game value</option>
     <option value="4 1/3">fractions are allowed</option>
     <option value="41"></option>
     <option value="120">a nicer value for 5 input numbers</option>
   </datalist>
   <br />
  <label for="solver_input">Input numbers:</label>
  <input type="text" id="solver_input"
         list="solver_input-examples"
         required="required"
         placeholder="Enter a few numbers (probably no more than 5)"
          data-parser="parseInput"
          data-error-message="enter one or more (fractional) numbers"
         />
   <datalist id="solver_input-examples">
     <option value="8 8 3 3">a hard one to make 24 with</option>
     <option value="4 7 7 7 8" >a hard one to make 120 with</option>

   </datalist>
  <br />
  <output id="solver_output"  for="solver_result solver_numbers"> </output>
  <br />
  <button name="submit">go!</button>
</form>
++++

[%collapsible, title=java source code]
====
This is the source code for the above.
[source,java]
----
package org.meeuw.math.demo;

import lombok.Getter;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Stream;

import lombok.extern.java.Log;

import org.meeuw.math.abstractalgebra.Ring;
import org.meeuw.math.abstractalgebra.RingElement;
import org.meeuw.math.abstractalgebra.complex.GaussianRationals;
import org.meeuw.math.abstractalgebra.permutations.PermutationGroup;
import org.meeuw.math.abstractalgebra.quaternions.Quaternions;
import org.meeuw.math.abstractalgebra.rationalnumbers.RationalNumbers;
import org.meeuw.math.arithmetic.ast.*;
import org.meeuw.math.exceptions.MathException;
import org.meeuw.math.exceptions.NotParsable;
import org.meeuw.math.operators.AlgebraicBinaryOperator;

import static org.meeuw.math.CollectionUtils.navigableSet;
import static org.meeuw.math.operators.BasicAlgebraicBinaryOperator.*;

/**
 * A tool to evaluate all possible expressions (of a certain number of rational numbers) (and check if it equals a certain value)
 */
@Log
public  class Solver<E extends RingElement<E>> {
    static {
        Application.setupLogging();
    }

    private static final NavigableSet<AlgebraicBinaryOperator> OPERATORS = navigableSet(
        ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION
    );

    private final AtomicLong tries = new AtomicLong();

    @Getter
    private final Ring<E> structure;

    public Solver(Ring<E> structure) {
        this.structure = structure;
    }

    @SafeVarargs
    public final Stream<Expression<E>> stream(E... set) {
        PermutationGroup permutations = PermutationGroup.ofDegree(set.length);

        return permutations.stream()
            .map(permutation -> permutation.permute(set))
            .map(List::of)
            .distinct()
            .flatMap(permuted ->
                AST.stream(
                    permuted,
                    OPERATORS
                )
            )
            .map( e -> e.canonize(structure))
            .distinct()
            .peek(e -> tries.getAndIncrement());
    }



    public Stream<EvaluatedExpression<E>> evaledStream(E... set) {
        return stream(set)
            .map(e -> {
                try {
                    E evaled = e.eval();
                    return new EvaluatedExpression<>(e, evaled);
                } catch (MathException ex) {
                    return null;
                }
            })
            .filter(Objects::nonNull);
    }

    /**
     *
     */
    public  static <E extends RingElement<E>> SolverResult solve(Ring<E> structure, String outcomeString, String inputStrings) {

        ParseResult<E> outcome = parseOutcome(structure, outcomeString);
        ParseResult<E[]> input = parseInput(structure, inputStrings);
        if (outcome.success() && input.success()) {
            return solve(structure, outcome.result(), input.result());
        } else {
            throw new NotParsable(outcome.error() + "/" + input.error());
        }
    }

    public  static <E extends RingElement<E>> SolverResult solve(Ring<E> structure, E outcome, E[] input) {

        Solver<E> solver = new Solver<>(structure);
        AtomicLong matches = new AtomicLong();
        log.info(() -> "Solving input " + List.of(input) + " for " + outcome + " ( in field " + structure + ")");

        return new SolverResult(solver.evaledStream(input)
            .filter(e ->
                e.result().eq(outcome)
            ).peek(e -> matches.getAndIncrement())
            .map(EvaluatedExpression::toString),
            solver.tries, matches, structure);
    }

    public static <F extends RingElement<F>> ParseResult<F> parseOutcome(Ring<F> field, String outcomeString) {
        log.info(() -> "Parsing input " + outcomeString + " in field " + field);

        String resultError = null;
        F result;
        try {
            result = field.fromString(outcomeString);
        } catch (NotParsable pe) {
            result = null;
            resultError = pe.getMessage();
        }
        return new ParseResult<F>(outcomeString, result, resultError);
    }
    public static <F extends RingElement<F>> ParseResult<F[]> parseInput(Ring<F> field, String inputStrings) {
        log.info(() -> "Parsing input " + inputStrings + " in field " + field);

        String inputError = null;

        String[] input = inputStrings.split("\\s+");
        F[] set = field.newArray(input.length);
        try {
            for (int i = 0; i < set.length; i++) {
                set[i] = field.fromString(input[i]);
            }
        } catch (NotParsable pe) {
            inputError = pe.getMessage();
        }
        return new ParseResult<>(inputStrings, set, inputError);
    }

    public static Ring<?> algebraicStructureFor(String outcomeString, String input) {
        log.info(() -> "Determining algebraic structure for outcome " + outcomeString + " and input " + input);
        if (outcomeString.matches(".*[jk].*") || input.matches(".*[jk].*")) {
            return Quaternions.of(RationalNumbers.INSTANCE);
        } else if (outcomeString.contains("i") || input.contains("i")) {
            return GaussianRationals.INSTANCE;
        } else {
            return RationalNumbers.INSTANCE;
        }
    }


    public record SolverResult(Stream<String> stream, AtomicLong tries, AtomicLong matches, Ring<?> field) {


    }

    public static void main(String[] integers) {
        if (integers.length < 3) {
            System.out.println();
            System.exit(1);
        }
        String resultString = integers[0];
        String inputStrings = String.join(" ", Arrays.copyOfRange(integers, 1, integers.length));

        Ring<?> field = algebraicStructureFor(resultString, inputStrings);
        SolverResult solverResult = Solver.solve(field, resultString, inputStrings);
        solverResult.stream().forEach(System.out::println);
        System.out.println("ready, found " + solverResult.matches().get() + ", tried " + solverResult.tries.get() + ", field " + solverResult.field().toString());
    }
}
----
====
[%collapsible, title=javascript]
====
This is the source code for the above.
[source,javascript]
----


    async onSubmit(Solver) {
        this.output.value += "using: " + await (this.model.field).toString();
        const solverResult = await Solver.solve(
            this.model.field, this.outcome.value, this.input.value
            );

        const stream = await solverResult.stream();
        const lines = await stream.toArray();
        for (let i = 0; i < lines.length; i++) {
            this.output.value += "\n" + await lines[i].toString();
        }
        const tries = await (await solverResult.tries()).get();
        const matches = await (await solverResult.matches()).get();
        this.output.value += `\nFound: ${matches}`;
        this.output.value += `\nTried: ${tries}`;
    }
}
----
====

:leveloffset!:

:leveloffset: 1

[#demo_dynamicdate]
= Dynamic date parsing

The `mihxil-time` module contain a 'dynamic date parser. I dusted this of from old link:mmbase.org[mmbase] code.

// tag::body[]

++++
<form id="dynamicdate" class="demo">
  <label for="dynamicdate_toparse">String to parse:</label> <input type="text" id="dynamicdate_toparse"  list="dynamicdate_toparse-examples" value="" />
   <datalist id="dynamicdate_toparse-examples">
    <option value="0"></option>
    <option value="10000"></option>
    <option value="-10000"></option>
    <option value="+1000"></option>
    <option value="1973-05-03"></option>
    <option value="2006-05-09"></option>
    <option value="-3-12-25"></option>
    <option value="2000-01-01 16:00"></option>
    <option value="TZUTC 2001-01-01 16:00"></option>
    <option value="today 12:34:56.789"></option>
    <option value="now"></option>
    <option value="today"></option>
    <option value="tomorrow"></option>
    <option value="now + 10 minute"></option>
    <option value="today + 5 day"></option>
    <option value="now this year"></option>
    <option value="next august"></option>
    <option value="today + 6 month next august"></option>
    <option value="tomonth"></option>
    <option value="borreltijd"></option>
    <option value="today + 5 dayish"></option>
    <option value="yesteryear"></option>
    <option value="mondayish"></option>
    <option value="duration + 5 minute"></option>
    <option value="duration + 100 year"></option>
    <option value="TZUTC today noon"></option>
    <option value="TZEurope/Amsterdam today noon"></option>
    <option value="TZUTC today"></option>
    <option value="TZEurope/Amsterdam today"></option>
    <option value="TZ UTC today noon"></option>
    <option value="TZ Europe/Amsterdam today noon"></option>
    <option value="TZ UTC today"></option>
    <option value="TZ Europe/Amsterdam today"></option>
    <option value="TZ Europe/Amsterdam -1000"></option>
    <option value="today 6 oclock"></option>
    <option value="today 23 oclock"></option>
    <option value="today 43 oclock"></option>
    <option value="tosecond"></option>
    <option value="tominute"></option>
    <option value="tohour"></option>
    <option value="today"></option>
    <option value="previous monday"></option>
    <option value="tomonth"></option>
    <option value="toyear"></option>
    <option value="tocentury"></option>
    <option value="tocentury_pedantic"></option>
    <option value="toera"></option>
    <option value="toweek"></option>
    <option value="now this second"></option>
    <option value="now this minute"></option>
    <option value="now this hour"></option>
    <option value="now this day"></option>
    <option value="today previous monday"></option>
    <option value="now this month"></option>
    <option value="now this year"></option>
    <option value="now this century"></option>
    <option value="now this era"></option>
    <option value="now - 15 year this century"></option>
    <option value="now - 20 year this century_pedantic"></option>
    <option value="today + 2 century"></option>
    <option value="toera - 1 minute"></option>
    <option value="this july"></option>
    <option value="previous july"></option>
    <option value="next july"></option>
    <option value="this sunday"></option>
    <option value="previous sunday"></option>
    <option value="next sunday"></option>
    <option value="2009-W01-01"></option>
    <option value="2009-W53-7"></option>
    <option value="2006-123"></option>
    <option value="2005-01-01 this monday"></option>
    <option value="next year"></option>
    <option value="&quot;spring&quot;"></option>
    <option value="next year &quot;spring&quot;"></option>
    <option value="&quot;easter sunday&quot;"></option>
   </datalist>
   <br />
  <output id="dynamicdate_output" for="dynamicdate_toparse"> </output>
  <br />
  <button name="submit">go!</button>
</form>
++++

[%collapsible, title=javascript]
====
This is the source code for the above.
[source,javascript]
----

async onSubmit(DynamicDateTime){
    try {
        const parser = await new DynamicDateTime();
        const parseResult = await parser.applyWithException(this.form.querySelector("#dynamicdate_toparse").value);
        this.output.value = await parseResult.toString();
    } catch (error) {
        console.log(error);
    }

}

----
====

//end::bodye[]

:leveloffset!:
