// DO NOT EDIT THIS FILE IT IS GENERATED!!
[#demo_section]
= Demo
:docinfo: private
:source-highlighter: coderay
:toc:

These are a running link:https://webassembly.org/[webassembly] demos (using link:https://cheerpj.com/docs/getting-started/Java-library[cheerpj]).


[NOTE]
====
This section is work in progress
====

:leveloffset: +1

[#demo_calculator]
[.tips-aside]
= Calculator


++++
<form id="calculator" class="demo">
  <label for="calculator_field">Field:</label>
  <select id="calculator_field"  >
   <!-- filled by calculator.js -->
  </select>
  <div class="help"></div>

++++


[TIP]
====
[#calculator_digits]
0::
1::
2::
3::
4::
5::
6::
7::
8::
9::

[#calculator_operators]
+:: for addition
-:: for subtraction
‚ãÖ:: for multiplication
/:: for division
\:: for euclidean division
%:: for modulo division
*:: for the default 'group operation'
^:: for exponentiation

[#calculator_unary_operator]
-:: negation

[#calculator_special]
( ):: brackets
"":: quotes

====


++++
<div class="form">
  <label for="calculator_toparse">Expression to evaluate: <span class="help"></span></label> <input type="text" id="calculator_toparse"  list="calculator_toparse-examples" value="" />
   <datalist id="calculator_toparse-examples">
   <!-- filled by calculator.js -->
   </datalist>
  <button name="submit">=</button>
  <output id="calculator_output" for="calculator_toparse"> </output>
</div>
</form>
++++

[%collapsible, title=java]
====
This is the source code for the above.
[source,java]
----

@Getter
public  enum FieldInformation {
    rational(RationalNumbers.INSTANCE, "1 + 2", "1 + 3/5"),
    real(RealField.INSTANCE, "1 + 2", "1 + 3/5", "sin(ùúã/2)", "sqr(ùúë) - ùúë"),
    bigdecimal(BigDecimalField.INSTANCE, "1 + 2", "1 + 3/5", "sin(ùúã/2)"),
    gaussian(GaussianRationals.INSTANCE, "1 + 2", "1 + 3/5", "\"1 + 2i\" ‚ãÖ 8i"),
    complex(ComplexNumbers.INSTANCE, "1 + 2", "1 + 3/5", "sin(ùúã/2)", "exp(-i ‚ãÖ ùúã)", "\"2 + 3i\" ‚ãÖ i"),
    bigcomplex(BigComplexNumbers.INSTANCE, "1 + 2", "1 + 3/5", "\"1 + 2i\" ‚ãÖ 8i"),
    quaternions(Quaternions.of(RationalNumbers.INSTANCE),
        "1 + 2", "1 + 3/5", "\"1 + 2i + 3j + 4k\" ‚ãÖ 8i"),
    quaternions_bigdecimal(Quaternions.of(BigDecimalField.INSTANCE),
        "1 + 2", "1 + 3/5", "\"1 + 2i + 3j + 4k\" ‚ãÖ 8i"),
    integers(Integers.INSTANCE, "4 ‚ãÖ 7", "9 - 3"),
    modulo10(ModuloRing.of(10), "4 ‚ãÖ 7", "9 - 3"),
    modulo13(ModuloField.of(13), "10 ‚ãÖ 7", "10 - 3", "12 ‚ãÖ 6 / 4"),
    natural(NaturalNumbers.INSTANCE, "10 ‚ãÖ 7", "10 - 3", "12 ‚ãÖ 6 / 4"),
    even(EvenIntegers.INSTANCE, "10 ‚ãÖ 8", "10 - 4"),
    squares(Squares.INSTANCE, "2 ‚ãÖ 9"),

    klein(KleinGroup.INSTANCE,
        "a * b * c * e",
        "a * b"
    ),
    quaterniongroup(QuaternionGroup.INSTANCE, "i * j", "j * i", "e * k * i" ),
    dihedral3(DihedralGroup.D3,
        "r1 * r2",
        "s0 * r1 * s0"
    ),
    dihedral4(DihedralGroup.of(4),
        "r1 * r2",
        "s0 * r1 * s0 * s3"
    ),
    polynomials(PolynomialRing.of(GaussianRationals.INSTANCE),
        "\"7¬∑x + 15¬∑x¬≤ + 2¬∑x¬≥ + 7¬∑x‚Åµ + x‚Å∂\" ‚ãÖ \"15¬∑x¬≤ + 2¬∑x¬≥\"",
        "\"x + 2x^2 + x^5\" + \"5 + 3/4x^2 - x^5\""
    )
    ;

    private final Magma<?> field;
    private final String[] examples;
    private final String[] elements;
    private final String[] binaryOperators;
    private final String[] unaryOperators;

    private final boolean finite;

    FieldInformation(Magma<?> field, String... examples) {
        this.field = field;
        this.finite = field.isFinite();
        this.examples = examples;
        this.elements = elements(field);
        this.binaryOperators = field.getSupportedOperators()
            .stream()
            .map(AlgebraicBinaryOperator::getSymbol)
            .toArray(String[]::new);

        this.unaryOperators = field.getSupportedUnaryOperators()
            .stream()
            .map(AlgebraicUnaryOperator::getSymbol)
            .toArray(String[]::new);

        log.fine("Created %s, operators: %s, unary: %s examples: %s, elements: %s".formatted(field,
            List.of(binaryOperators),
            List.of(unaryOperators),
            List.of(examples), List.of(elements)));
    }

    public static String[] elements(Magma<?> field) {
        Set<String> elements = new LinkedHashSet<>(field.getConstants().keySet());
        if (field.getCardinality().isCountable() && field instanceof  Streamable<?> streamable) {
            try {
                streamable.stream().limit(100).map(Object::toString).forEach(elements::add);
            } catch (NotStreamable ignored) {}
        }
        return elements.toArray(new String[0]);
    }

    public String getDescription() {
        return field.getClass().getSimpleName() + " " + field;
    }

    public String getHelp() {
        return field.getDescription().orElse(null);
    }
}



public static String eval(String input, final String field) {
    final String expression = input.strip();
    try (var r = ConfigurationService.setConfiguration(cb -> cb
        .configure(UncertaintyConfiguration.class,
            (ub) -> ub.withNotation(ROUND_VALUE))
        .configure(MathContextConfiguration.class,
            (mc) -> mc.withContext(new MathContext(Utils.PI.length())))
    )) {
        var f = FieldInformation.valueOf(field).getField();

        log.fine(() -> "Evaluating expression in %s: %s. Binary: %s, Unary: %s".formatted(f, expression, f.getSupportedOperators(), f.getSupportedUnaryOperators()));
        if (f.getSupportedOperators().isEmpty()) {
            log.log(Level.SEVERE,  "Supported operators is empty for " + f);
        }
        var parsedExpression = AST.parse(expression, f);
        log.fine(() -> "Parsed expression: %s".formatted( parsedExpression));
        var result = parsedExpression.eval();
        var resultAsString = result.toString();
        log.info(() -> "Result: %s = %s".formatted(expression, resultAsString));
        return resultAsString;
    } catch (Throwable ex) {
        log.log(Level.SEVERE,  ex.getClass() + " " + ex.getMessage(), ex);
        throw ex;
    } finally {
        log.finer("Ready evaluation");
    }
}
----
====
[%collapsible, title=javascript]
====
This is the source code for the above.
[source,javascript]
----
    constructor() {
        super('#calculator', 'org.meeuw.math.demo.Calculator');
        this.input = this.form.querySelector('input');
        this.field = this.form.querySelector('select');
        this.inputDataList= this.form.querySelector('datalist');
        this.information = null;
    }

    insert(string) {
        const input = this.input;
        const start = input.selectionStart;
        const end = input.selectionEnd;
        const value = input.value;
        input.value = value.slice(0, start) + string + value.slice(end);
        input.setSelectionRange(
            start + string.length,
            start + string.length
        );
        input.focus();
    }

    insertOperator(string) {
        const needsBrackets = string.length > 1;
        if (! needsBrackets) {
            return this.insert(string);
        }
        const input = this.input;
        const start = input.selectionStart;
        const end = input.selectionEnd;
        const value = input.value;
        if (start === end) {
            input.value = string + "(" + value + ")";
            input.setSelectionRange(
                start + string.length + 1,
                start + string.length + 1
            );
        } else {
            input.value = value.slice(0, start) + string + "(" + value.slice(start, end) + ")" + value.slice(end);
            input.setSelectionRange(
                start,
                end  + string.length + 2
            );
        }

        input.focus();
    }

    async setupForm() {
        await super.setupForm();
        this.form.addEventListener('beforeinput', async (e) => {
            this.form.querySelector("span.help").innerHTML = '';
            if (e.data === '=') {
                console.log(this.input.value);
                e.preventDefault();
                e.stopImmediatePropagation();
                await this.handleSubmit();
            }
             if (e.data === '*') {
                 this.form.querySelector("span.help").innerHTML = "to type * use ;";
                 e.preventDefault();
                 e.stopImmediatePropagation();
                 this.insert('‚ãÖ')
             }
            if (e.data === ';') {
                 e.preventDefault();
                 e.stopImmediatePropagation();
                 this.insert('*')
             }
        });
    }

    async onInView(Calculator){
        await super.onInView(Calculator);
        if (this.information === null) {
            await this.loadInformation();
            await this.updateFieldList();
            await this.updateExamples();
            await this.updateHelp();
            await this.updateOperators();
            await this.updateDigits();
        }

        this.field.addEventListener('change', () => {
            this.updateExamples();
            this.updateHelp();
            this.updateOperators();
            this.updateDigits();

        });



    }

    updateFieldList() {
        for (const [key, value] of Object.entries(this.information)) {
            const option = document.createElement('option');
            option.value = key;
            option.text = value.description;
            this.field.appendChild(option);
        }
    }

    /**
     * Load all information about the supported fields
     */
    async loadInformation() {
        this.information = {};
        const fi = await (await BaseClass.cj)['org.meeuw.math.demo.Calculator$FieldInformation'];
        const values = await fi.values();

        for (let i = 0; i < values.length; i++) {
            const value = await values[i];
            const elements = await BaseClass.awaitedArray(value.getElements());
            let elementSpans = null;
            if (elements) {
                elementSpans = [];
                for (let j = 0; j < elements.length; j++) {
                    const span = document.createElement('span');
                    span.classList.add('element');
                    span.textContent = elements[j];
                    span.onclick = async e => {
                        this.insert(e.target.textContent);
                    };
                    elementSpans[j] = span;
                }
            }
            this.information[await values[i].name()] = {
                examples: await BaseClass.awaitedArray(value.getExamples()),
                elements: elements,
                elementsSpans: elementSpans,
                binaryOperators: await BaseClass.awaitedArray(value.getBinaryOperators()),
                unaryOperators: await BaseClass.awaitedArray(value.getUnaryOperators()),
                finite: await value.isFinite(),
                description: await value.getDescription(),
                help: await value.getHelp()
            };
        }
        console.log("information", JSON.stringify(this.information,  (key, value) => {
            if (key === 'elementsSpans') {
                return undefined;
            }
            return value;
        } , 1));
    }

    /**
     *
     */
    async updateExamples() {
        const selectedField = this.field.value;
        const information = this.information[selectedField];
        if (information) {
            this.inputDataList.innerHTML = '';
            for (const example of information.examples) {
                const option = document.createElement('option');
                option.value = example;
                this.inputDataList.appendChild(option);
            }
            console.log("Updated example li for", selectedField, information.examples);
        }
    }
    async updateHelp() {
        const fieldInformation =  this.information[this.field.value];
        const div = this.field.parentNode.querySelector("div.help");
        div.innerHTML = '';
        let help = fieldInformation.help;
        if (help) {
            div.appendChild(document.createTextNode(help));
        }
        const elements = this.information[this.field.value].elementSpans;
        if (elements) {
            div.appendChild(document.createElement("br"));
            div.appendChild(document.createTextNode("elements: "));
            elements.forEach(element => {
                div.appendChild(element);
            })
            if (!fieldInformation.finite) {
                div.appendChild(document.createTextNode("... infinitely many more"));
            }
        }
    }
    operatorDts(dl, operators) {
        this.dts(dl, operators, async e => {
            this.insertOperator(e.target.textContent);
        });
    }


    dts(dl, items, onclick, limit=10000) {
        const list = dl.querySelectorAll("dt");

        const currentlyInList = Array.from(list).map(e => e.textContent.trim());
        const unmatchedItems = items.slice(0, limit).filter(op => !currentlyInList.includes(op));

        // add the ones not yet in it.
        unmatchedItems.forEach(op => {
            const dt = document.createElement("dt");
            //dt.classList.add('hdlist1');
            dt.textContent = op;
            dl.appendChild(dt);
            const dd = document.createElement("dd");
            dl.appendChild(dd);
        });
        let count = 0;
        for (const e of dl.querySelectorAll("dt")) {
            const symbol = e.textContent.trim();
            const title = e.nextElementSibling.textContent;
            if (!e.hasAttribute("original-display")) {
                e.setAttribute("original-display", window.getComputedStyle(e).display);
                e.onclick =onclick;
            }
            if (!items.includes(symbol)) {
                e.style.display = 'none';
                e.nextElementSibling.hidden = true;
            } else {
                e.title = title;
                e.style.display = e.getAttribute("original-display");
                e.nextElementSibling.hidden = false;
                count++;
                if (count >= limit) {
                    break;
                }
            }
        }
    }

    async updateOperators() {
        const fieldInformation =  this.information[this.field.value];
        const operators = fieldInformation.binaryOperators;
        this.operatorDts(document.querySelector("#calculator_operators dl"), operators);
        const unaryOperators = fieldInformation.unaryOperators;
        this.operatorDts(document.querySelector("#calculator_unary_operator dl"), unaryOperators);
    }


    async updateDigits() {
        const fieldInformation =  this.information[this.field.value];
        const elements = fieldInformation.elements;
        this.dts(document.querySelector("#calculator_digits dl"), elements, async e => {
            this.insert(e.target.textContent);
        }, 10);

    }

    async onSubmit(Calculator) {
        this.output.value = '';
        this.textContent = "executing..";
        //console.log("evaluating", this.input.value, "for", this.field.value);
        this.output.value = await Calculator.eval(
            this.input.value, this.field.value
        );
    }

}
----
====

:leveloffset!:

:leveloffset: +1

[#demo_solver]
= Solver

The same idea as my link:https://meeuw.org/flippo/flippo.html[very first applet]. Solving the '24 flippo game'.

Give the desired outcome number, and a few input numbers, and it will find the possible ways to get it using those input numbers.

[NOTE]
====
This combines several aspects of this project:

- It uses 'rational numbers' to make all operations exact
- It uses the permutation group to permute all combinations of values
- It uses the Abstract Syntax Tree feature to combine values and operators
- It uses some features of the Field, e.g. to perform operators generically.
- It will currently use the field of `RationalNumbers` _or_ `GaussianRationals` if the input contains a complex number. I might add also support for `RealField` (and for example also support the POW operator)

====

++++
<form id="solver" class="demo">
  <label for="solver_outcome">Desired outcome:</label>
  <input type="text"
         required="required"
         id="solver_outcome"  list="solver_outcome-examples"
         data-parser="parseOutcome"
         data-error-message="enter one (fractional) number"
         value="24"/>
  <datalist id="solver_outcome-examples">
     <option value="24">the original 24 game value</option>
     <option value="4 1/3">fractions are allowed</option>
     <option value="41"></option>
     <option value="120">a nicer value for 5 input numbers</option>
   </datalist>
   <br />
  <label for="solver_input">Input numbers:</label>
  <input type="text" id="solver_input"
         list="solver_input-examples"
         required="required"
         placeholder="Enter a few numbers (probably no more than 5)"
          data-parser="parseInput"
          data-error-message="enter one or more (fractional) numbers"
         />
   <datalist id="solver_input-examples">
     <option value="8 8 3 3">a hard one to make 24 with</option>
     <option value="4 7 7 7 8" >a hard one to make 120 with</option>

   </datalist>
  <br />
  <output id="solver_output"  for="solver_result solver_numbers"> </output>
  <br />
  <button name="submit">go!</button>
</form>
++++

[%collapsible, title=java source code]
====
This is the source code for the above.
[source,java]
----
package org.meeuw.math.demo;

import lombok.Getter;
import lombok.extern.java.Log;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Stream;

import org.meeuw.math.abstractalgebra.Ring;
import org.meeuw.math.abstractalgebra.RingElement;
import org.meeuw.math.abstractalgebra.complex.GaussianRationals;
import org.meeuw.math.abstractalgebra.permutations.PermutationGroup;
import org.meeuw.math.abstractalgebra.quaternions.Quaternions;
import org.meeuw.math.abstractalgebra.rationalnumbers.RationalNumbers;
import org.meeuw.math.arithmetic.ast.*;
import org.meeuw.math.exceptions.MathException;
import org.meeuw.math.exceptions.NotParsable;
import org.meeuw.math.operators.AlgebraicBinaryOperator;

import static org.meeuw.math.CollectionUtils.navigableSet;
import static org.meeuw.math.operators.BasicAlgebraicBinaryOperator.*;

/**
 * A tool to evaluate all possible expressions (of a certain number of rational numbers) (and check if it equals a certain value)
 */
@Log
public  class Solver<E extends RingElement<E>> {
    private static final NavigableSet<AlgebraicBinaryOperator> OPERATORS = navigableSet(
        ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION
    );

    private final AtomicLong tries = new AtomicLong();

    @Getter
    private final Ring<E> structure;

    public Solver(Ring<E> structure) {
        this.structure = structure;
    }

    @SafeVarargs
    public final Stream<Expression<E>> stream(E... set) {
        PermutationGroup permutations = PermutationGroup.ofDegree(set.length);

        return permutations.stream()
            .map(permutation -> permutation.permute(set))
            .map(List::of)
            .distinct()
            .flatMap(permuted ->
                AST.stream(
                    permuted,
                    OPERATORS
                )
            )
            .map( e -> e.canonize(structure))
            .distinct()
            .peek(e -> tries.getAndIncrement());
    }



    public Stream<EvaluatedExpression<E>> evaledStream(E... set) {
        return stream(set)
            .map(e -> {
                try {
                    E evaled = e.eval();
                    return new EvaluatedExpression<>(e, evaled);
                } catch (MathException ex) {
                    return null;
                }
            })
            .filter(Objects::nonNull);
    }

    /**
     *
     */
    public  static <E extends RingElement<E>> SolverResult solve(Ring<E> structure, String outcomeString, String inputStrings) {

        ParseResult<E> outcome = parseOutcome(structure, outcomeString);
        ParseResult<E[]> input = parseInput(structure, inputStrings);
        if (outcome.success() && input.success()) {
            return solve(structure, outcome.result(), input.result());
        } else {
            throw new NotParsable(outcome.error() + "/" + input.error());
        }
    }

    public  static <E extends RingElement<E>> SolverResult solve(Ring<E> structure, E outcome, E[] input) {

        Solver<E> solver = new Solver<>(structure);
        AtomicLong matches = new AtomicLong();
        log.info(() -> "Solving input " + List.of(input) + " for " + outcome + " ( in field " + structure + ")");

        return new SolverResult(solver.evaledStream(input)
            .filter(e ->
                e.result().eq(outcome)
            ).peek(e -> matches.getAndIncrement())
            .map(EvaluatedExpression::toString),
            solver.tries, matches, structure);
    }

    public static <F extends RingElement<F>> ParseResult<F> parseOutcome(Ring<F> field, String outcomeString) {
        log.info(() -> "Parsing input " + outcomeString + " in field " + field);

        String resultError = null;
        F result;
        try {
            result = field.fromString(outcomeString);
        } catch (NotParsable pe) {
            result = null;
            resultError = pe.getMessage();
        }
        return new ParseResult<F>(outcomeString, result, resultError);
    }
    public static <F extends RingElement<F>> ParseResult<F[]> parseInput(Ring<F> field, String inputStrings) {
        log.info(() -> "Parsing input " + inputStrings + " in field " + field);

        String inputError = null;

        String[] input = inputStrings.split("\\s+");
        F[] set = field.newArray(input.length);
        try {
            for (int i = 0; i < set.length; i++) {
                set[i] = field.fromString(input[i]);
            }
        } catch (NotParsable pe) {
            inputError = pe.getMessage();
        }
        return new ParseResult<>(inputStrings, set, inputError);
    }

    public static Ring<?> algebraicStructureFor(String outcomeString, String input) {
        log.info(() -> "Determining algebraic structure for outcome " + outcomeString + " and input " + input);
        if (outcomeString.matches(".*[jk].*") || input.matches(".*[jk].*")) {
            return Quaternions.of(RationalNumbers.INSTANCE);
        } else if (outcomeString.contains("i") || input.contains("i")) {
            return GaussianRationals.INSTANCE;
        } else {
            return RationalNumbers.INSTANCE;
        }
    }


    public record SolverResult(Stream<String> stream, AtomicLong tries, AtomicLong matches, Ring<?> field) {


    }

    public static void main(String[] integers) {
        if (integers.length < 3) {
            System.out.println();
            System.exit(1);
        }
        String resultString = integers[0];
        String inputStrings = String.join(" ", Arrays.copyOfRange(integers, 1, integers.length));

        Ring<?> field = algebraicStructureFor(resultString, inputStrings);
        SolverResult solverResult = Solver.solve(field, resultString, inputStrings);
        solverResult.stream().forEach(System.out::println);
        System.out.println("ready, found " + solverResult.matches().get() + ", tried " + solverResult.tries.get() + ", field " + solverResult.field().toString());
    }
}
----
====
[%collapsible, title=javascript]
====
This is the source code for the above.
[source,javascript]
----


    async onSubmit(Solver) {
        this.output.value += "using: " + await (this.model.field).toString();
        const solverResult = await Solver.solve(
            this.model.field, this.outcome.value, this.input.value
        );
        // using iterator, because I can't figure out java lambda's here.
        const stream = await (await solverResult.stream()).iterator();
        while(await stream.hasNext()) {
            const line = await stream.next();
            this.output.value += "\n" + await line.toString();
            this.output.scrollTop = this.output.scrollHeight;
        }
        const matches = await (await solverResult.matches()).get();
        this.output.value += `\nFound: ${matches}`;
        const tries = await (await solverResult.tries()).get();
        this.output.value += `\nTried: ${tries}`;
    }
}
----
====

:leveloffset!:

:leveloffset: +1

[#demo_dynamicdate]
= Dynamic date parsing

The link:https://github.com/mihxil/math/tree/main/mihxil-time[`mihxil-time`] module contain a 'dynamic date parser. I dusted this of from old link:mmbase.org[mmbase] code.

// tag::body[]

++++
<form id="dynamicdate" class="demo">
  <label for="dynamicdate_toparse">String to parse:</label> <input type="text" id="dynamicdate_toparse"  list="dynamicdate_toparse-examples" value="" />
   <datalist id="dynamicdate_toparse-examples">
    <option value="0"></option>
    <option value="10000"></option>
    <option value="-10000"></option>
    <option value="+1000"></option>
    <option value="1973-05-03"></option>
    <option value="2006-05-09"></option>
    <option value="-3-12-25"></option>
    <option value="2000-01-01 16:00"></option>
    <option value="TZUTC 2001-01-01 16:00"></option>
    <option value="today 12:34:56.789"></option>
    <option value="now"></option>
    <option value="today"></option>
    <option value="tomorrow"></option>
    <option value="now + 10 minute"></option>
    <option value="today + 5 day"></option>
    <option value="now this year"></option>
    <option value="next august"></option>
    <option value="today + 6 month next august"></option>
    <option value="tomonth"></option>
    <option value="borreltijd"></option>
    <option value="today + 5 dayish"></option>
    <option value="yesteryear"></option>
    <option value="mondayish"></option>
    <option value="duration + 5 minute"></option>
    <option value="duration + 100 year"></option>
    <option value="TZUTC today noon"></option>
    <option value="TZEurope/Amsterdam today noon"></option>
    <option value="TZUTC today"></option>
    <option value="TZEurope/Amsterdam today"></option>
    <option value="TZ UTC today noon"></option>
    <option value="TZ Europe/Amsterdam today noon"></option>
    <option value="TZ UTC today"></option>
    <option value="TZ Europe/Amsterdam today"></option>
    <option value="TZ Europe/Amsterdam -1000"></option>
    <option value="today 6 oclock"></option>
    <option value="today 23 oclock"></option>
    <option value="today 43 oclock"></option>
    <option value="tosecond"></option>
    <option value="tominute"></option>
    <option value="tohour"></option>
    <option value="today"></option>
    <option value="previous monday"></option>
    <option value="tomonth"></option>
    <option value="toyear"></option>
    <option value="tocentury"></option>
    <option value="tocentury_pedantic"></option>
    <option value="toera"></option>
    <option value="toweek"></option>
    <option value="now this second"></option>
    <option value="now this minute"></option>
    <option value="now this hour"></option>
    <option value="now this day"></option>
    <option value="today previous monday"></option>
    <option value="now this month"></option>
    <option value="now this year"></option>
    <option value="now this century"></option>
    <option value="now this era"></option>
    <option value="now - 15 year this century"></option>
    <option value="now - 20 year this century_pedantic"></option>
    <option value="today + 2 century"></option>
    <option value="toera - 1 minute"></option>
    <option value="this july"></option>
    <option value="previous july"></option>
    <option value="next july"></option>
    <option value="this sunday"></option>
    <option value="previous sunday"></option>
    <option value="next sunday"></option>
    <option value="2009-W01-01"></option>
    <option value="2009-W53-7"></option>
    <option value="2006-123"></option>
    <option value="2005-01-01 this monday"></option>
    <option value="next year"></option>
    <option value="&quot;spring&quot;"></option>
    <option value="next year &quot;spring&quot;"></option>
    <option value="&quot;easter sunday&quot;"></option>
   </datalist>
   <br />
  <output id="dynamicdate_output" for="dynamicdate_toparse"> </output>
  <br />
  <button name="submit">go!</button>
</form>
++++

[%collapsible, title=javascript]
====
This is the source code for the above.
[source,javascript]
----

async onSubmit(DynamicDateTime){
    try {
        const parser = await new DynamicDateTime();
        const parseResult = await parser.applyWithException(this.form.querySelector("#dynamicdate_toparse").value);
        this.output.value = await parseResult.toString();
    } catch (error) {
        console.log(error);
        this.output.value = await (await error.getMessage()).toString();

    }

}

----
====

//end::body[]

:leveloffset!:
