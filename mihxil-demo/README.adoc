// DO NOT EDIT THIS FILE IT IS GENERATED!!
= Demo
:docinfo: private
:source-highlighter: coderay


These are a running demos (using link:https://cheerpj.com/docs/getting-started/Java-library[cheerpj]). It doesn't always work.

== Solver

The same idea as my link:https://meeuw.org/flippo/flippo.html[very first applet]. Solving the '24 flippo game'.

Give the desired outcome number, and a few input numbers, and it will find the possible ways to get it using those input numbers.

This combines several aspects of this project:

- It uses 'rational numbers' to make all operations exact
- It uses the permutation group to permute all combinations of values
- It uses the Abstract Syntax Tree feature to combine values and operators
- It uses some features of the Field, e.g. to perform operators generically.
- It will currently use the field of `RationalNumbers` _or_ `GaussianRationals` if the input contains a complex number. I might add also suport for `RealField` (and for example also support the POW operator)

++++
<form id="solver" class="demo">
  <label for="solver_result">Desired outcome:</label>
  <input type="text"
         required="required"
         id="solver_result"  list="solver_result-examples"
         data-parser="parseResult"
         data-error-message="enter one (fractional) number"
         value="24"/>
  <datalist id="solver_result-examples">
     <option value="24">24, the original 24 game value</option>
     <option value="4 1/3">factions are allowed</option>
     <option value="41"></option>
     <option value="120">120, a nicer value for 5 input numbers</option>
   </datalist>
   <br />
  <label for="solver_numbers">Input numbers:</label>
  <input type="text" id="solver_numbers"
         list="solver_numbers-examples"
         required="required"
         placeholder="Enter a few numbers (probably no more than 5)"
          data-parser="parseInput"
          data-error-message="enter one or more (fractional) numbers"
         />
   <datalist id="solver_numbers-examples">
     <option value="8 8 3 3">a hard one to make 24 with</option>
     <option value="4 7 7 7 8" >a hard one to make 120 with</option>

   </datalist>
  <br />
  <output id="solver_output"  for="solver_result solver_numbers"> </output>
  <br />
  <button name="submit">go!</button>
</form>
++++

[%collapsible, title=java source code]
====
This is the source code for the above.
[source,java]
----
package org.meeuw.math.test;

import lombok.Getter;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Stream;

import org.meeuw.math.abstractalgebra.Field;
import org.meeuw.math.abstractalgebra.FieldElement;
import org.meeuw.math.abstractalgebra.complex.GaussianRationals;
import org.meeuw.math.abstractalgebra.permutations.PermutationGroup;
import org.meeuw.math.abstractalgebra.rationalnumbers.RationalNumbers;
import org.meeuw.math.arithmetic.ast.*;
import org.meeuw.math.exceptions.MathException;
import org.meeuw.math.exceptions.NotParsable;
import org.meeuw.math.operators.AlgebraicBinaryOperator;

import static org.meeuw.math.CollectionUtils.navigableSet;
import static org.meeuw.math.operators.BasicAlgebraicBinaryOperator.*;

/**
 * A tool to evaluate all possible expressions (of a certain number of rational numbers) (and check if it equals a certain value)
 */
public  class Solver<E extends FieldElement<E>> {

    private static final NavigableSet<AlgebraicBinaryOperator> OPERATORS = navigableSet(
        ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION
    );

    private final AtomicLong tries = new AtomicLong();

    @Getter
    private final Field<E> structure;

    public Solver(Field<E> structure) {
        this.structure = structure;
    }

    public Stream<Expression<E>> stream(E... set) {
        PermutationGroup permutations = PermutationGroup.ofDegree(set.length);

        return permutations.stream()
            .map(permutation -> permutation.permute(set))
            .map(List::of)
            .distinct()
            .flatMap(permuted ->
                AST.stream(
                    permuted,
                    OPERATORS
                )
            )
            .map( e -> e.canonize(structure))
            .distinct()
            .peek(e -> tries.getAndIncrement());
    }



    public Stream<EvaluatedExpression<E>> evaledStream(E... set) {
        return stream(set)
            .map(e -> {
                try {
                    E evaled = e.eval();
                    return new EvaluatedExpression<>(e, evaled);
                } catch (MathException ex) {
                    return null;
                }
            })
            .filter(Objects::nonNull);
    }

    public  static <E extends FieldElement<?>> SolverResult solve(String resultString, String[] numbers) {
        if (resultString.contains("i") || Stream.of(numbers).anyMatch(s -> s.contains("i"))) {
            return solve(GaussianRationals.INSTANCE, resultString, numbers);
        } else {
            return solve(RationalNumbers.INSTANCE, resultString, numbers);
        }

    }

    /**
     *
     */
    public  static <E extends FieldElement<E>> SolverResult solve(Field<E> structure, String resultString, String[] numbers) {

        ParseResult<E> parseResult = ParseResult.parse(structure, resultString, numbers);
        return solve(parseResult);
    }

    public  static <E extends FieldElement<E>> SolverResult solve(ParseResult<E> parseResult) {

        Solver<E> solver = new Solver<>(parseResult.field);
        AtomicLong matches = new AtomicLong();
        return new SolverResult(solver.evaledStream(parseResult.input)
            .filter(e ->
                e.result().eq(parseResult.result)
            ).peek(e -> matches.getAndIncrement())
            .map(EvaluatedExpression::toString),
            solver.tries, matches, parseResult.field);
    }

    public record SolverResult(Stream<String> stream, AtomicLong tries, AtomicLong matches, Field<?> field) {

    }

    public record ParseResult<E extends FieldElement<E>>(
        E result,
        E[] input,
        Field<E> field,
        String resultError,
        String inputError) {

        public static <F extends FieldElement<F>> ParseResult<F> parse(Field<F> field, String resultString, String... input) {
            String resultError = null;
            F  result;
            try {
                result = field.parse(resultString);
            } catch (NotParsable pe) {
                result = null;
                resultError = pe.getMessage();
            }
            String inputError = null;
            F[] set = field.newArray(input.length);
            try {
                for (int i = 0; i < set.length; i++) {
                    set[i] = field.parse(input[i]);
                }
            } catch (NotParsable pe) {
                inputError = pe.getMessage();
            }
            return new ParseResult<>(result, set, field, resultError, inputError);
        }

        public static ParseResult<?> parse(String resultString, String... input) {
            if (resultString.contains("i") || Stream.of(input).anyMatch(s -> s.contains("i"))) {
                return parse(GaussianRationals.INSTANCE, resultString, input);
            } else {
                return parse(RationalNumbers.INSTANCE, resultString, input);
            }
        }

    }

    public static void main(String[] integers) {
        if (integers.length < 3) {
            System.out.println();
            System.exit(1);
        }

        ParseResult<?> parseResult = ParseResult.parse(integers[0], Arrays.copyOfRange(integers, 1, integers.length));
        SolverResult result = Solver.solve(parseResult);
        result.stream().forEach(System.out::println);
        System.out.println("ready, found " + result.matches().get() + ", tried " + result.tries.get() + ", field " + result.field().toString());
    }
}
----
====
[%collapsible, title=javascript]
====
This is the source code for the above.
[source,javascript]
----


async function setupSolver() {

    const form = document.querySelector('#solver');
    const button = form.querySelector('button');
    const buttonText = button.textContent;
    const output = form.querySelector('output');
    const result = form.querySelector("#solver_result");
    const numbers = form.querySelector("#solver_numbers");
    function go() {
        button.textContent = buttonText;
        button.disabled = false;
    }


    const model = {
        ParseResult: null,
        result: null,
        parseIfNeeded: async function() {
          if (this.result == null) {
              await this.parse();
          }
          return this.result;
        },

        parse: async function() {
            const splitNumbers = numbers.value.split(" ");
            if (this.ParseResult == null) {
                this.ParseResult = await setupFormWithClass(button, 'org.meeuw.math.test.Solver$ParseResult');
            }
            this.result = await this.ParseResult.parse(result.value, splitNumbers);
            go();
        },
        parseResult:  async function(input) {
            await this.parse();
            return await this.result.resultError();
        },
        parseInput :  async function(input) {
            await this.parse()
            return await this.result.inputError();
        },
        reset: function() {
            this.result =null;
        }
    };
    result['model'] = model;
    numbers['model'] = model;


    let Solver = null;
    form.onsubmit = async (e) => {
        e.preventDefault();
        Solver = await setupFormWithClass(button, 'org.meeuw.math.test.Solver');

        output.value = '';
        button.textContent = "executing..";
        try {
            const parseResult = await model.parseIfNeeded();
            output.value += "using: " + await (await parseResult.field()).toString();
            const solverResult = await Solver.solve(parseResult);

            const stream = await solverResult.stream();
            const lines = await stream.toArray();
            for (let i = 0; i < lines.length; i++) {
                output.value += "\n" + await lines[i].toString();
            }
            const tries = await (await solverResult.tries()).get();
            const matches = await (await solverResult.matches()).get();
            output.value += `\nFound: ${matches}`;
            output.value += `\nTried: ${tries}`;

        } catch (error) {
            output.value += await error.toString();
        }
        go();

    };
}

----
====


== Dynamic date parsing

The `mihxil-time` module contain a 'dynamic date parser`

++++
<form id="dynamicdate" class="demo">
  <label for="dynamicdate_toparse">String to parse:</label> <input type="text" id="dynamicdate_toparse"  list="dynamicdate_toparse-examples" value="" />
   <datalist id="dynamicdate_toparse-examples">
     <option value="tomorrow"></option>
     <option value="next friday"></option>
   </datalist>
   <br />
  <output id="dynamicdate_output" for="dynamicdate_toparse"> </output>
  <br />
  <button name="submit">go!</button>
</form>
++++

[%collapsible, title=javascript]
====
This is the source code for the above.
[source,javascript]
----


async function setupDynamicDate() {

    const form = document.querySelector('#dynamicdate');
    const button = form.querySelector('button');
    const buttonText = button.textContent;
    const output = form.querySelector('output');



    let DynamicDateTime = null;
    form.onsubmit = async (e) => {
        e.preventDefault();
        DynamicDateTime = await setupFormWithClass(button, 'org.meeuw.time.dateparser.DynamicDateTime');
        button.textContent = "executing..";
        try {
            const parser = await new DynamicDateTime();
            const parseResult = await parser.applyWithException(form.querySelector("#dynamicdate_toparse").value);
            output.value = await parseResult.toString();
        } catch (error) {
            output.value = await error.toString();
        }
        button.textContent = buttonText;
        button.disabled = false;
    };
}

----
====
