// DO NOT EDIT THIS FILE IT IS GENERATED!!
= Demo
:docinfo: private
:source-highlighter: coderay

These are a running link:https://webassembly.org/[webassembly] demos (using link:https://cheerpj.com/docs/getting-started/Java-library[cheerpj]).

It doesn't always work, which I haven't quit understood yet.


== Calculator

++++
<form id="calculator" class="demo">
  <label for="calculator_toparse">String to evaluate: <span class="help"></span></label> <input type="text" id="calculator_toparse"  list="calculator_toparse-examples" value="" />
   <datalist id="calculator_toparse-examples">
   <!-- filled by calculator.js -->
   </datalist>
   <label for="calculator_field">Field:</label>
   <select id="calculator_field"  >
   <!-- filled by calculator.js -->
   </select>
   <br />
  <output id="calculator_output" for="calculator_toparse"> </output>
  <br />
  <button name="submit">go!</button>
</form>
++++

[%collapsible, title=java]
====
This is the source code for the above.
[source,java]
----

public static String eval(final String expression, final String field) {


    try (ConfigurationService.Reset r = ConfigurationService.setConfiguration(cb ->
        cb.configure(UncertaintyConfiguration.class,
                (ub) -> ub.withNotation(ROUND_VALUE))
            .configure(MathContextConfiguration.class,
                (mc) ->
                    mc.withContext(new MathContext(Utils.PI.length())))
    )) {
        Magma<?> f = FieldInformation.valueOf(field).getField();
        log.info("Evaluating expression in %s: %s. Binary: %s, Unary: %s".formatted(f, expression, f.getSupportedOperators(), f.getSupportedUnaryOperators()));
        log.info("Parsing expression: %s".formatted( expression));

        Expression<?> parsedExpression = AST.parseInfix(expression, f);
        try {
            log.info("Parsed expression: %s".formatted( parsedExpression));
            AlgebraicElement<?> result = parsedExpression.eval();
            String resultAsString = result.toString();
            log.info("Result: %s = %s".formatted(expression, resultAsString));
            return resultAsString;
        } catch (Throwable ex) {
            log.log(Level.SEVERE, "odd1:" +  ex.getClass() + " " + ex.getMessage(), ex);
            throw ex;
        }
    } catch (Throwable ex) {
        log.log(Level.SEVERE, "odd: " + ex.getClass() + " " + ex.getMessage(), ex);
        throw ex;
    } finally {
        log.finer("Ready evaluation");
    }
}
----
====
[%collapsible, title=javascript]
====
This is the source code for the above.
[source,javascript]
----
    constructor() {
        super('#calculator', 'org.meeuw.math.test.Calculator');
        this.input = this.form.querySelector('input');
        this.field = this.form.querySelector('select');
        this.inputDataList= this.form.querySelector('datalist');
        this.information = null;
    }

    insert(c) {
        const input = this.input;
        const start = input.selectionStart;
        const end = input.selectionEnd;
        const value = input.value;
        input.value = value.slice(0, start) + c + value.slice(end);
        input.setSelectionRange(start + 1, start + 1);
    }

    async setupForm() {
        await super.setupForm();
        this.form.addEventListener('beforeinput', async (e) => {
            this.form.querySelector("span.help").innerHTML = '';
            if (e.data === '=') {
                console.log(this.input.value);
                e.preventDefault();
                e.stopImmediatePropagation();
                await this.handleSubmit();
            }
             if (e.data === '*') {
                 this.form.querySelector("span.help").innerHTML = "to type * use [";
                 e.preventDefault();
                 e.stopImmediatePropagation();
                 this.insert('â‹…')
             }
            if (e.data === '[') {
                 e.preventDefault();
                 e.stopImmediatePropagation();
                 this.insert('*')
             }
        });
    }

    async onInView(Calculator){

        await super.onInView(Calculator);
        // using the field information to update the example per field
        if (this.information === null) {
            this.information = {};
            const fi = await (await BaseClass.cj)['org.meeuw.math.test.Calculator$FieldInformation'];
            const values = await fi.values();

            for (let i = 0; i < values.length; i++) {
                const value = values[i];
                const examples = await value.getExamples();
                const description = await value.getDescription();
                const field = await value.getField();
                const string = await field.toString();

                const e = [];
                for (let j = 0; j < examples.length; j++) {
                    e[j] = await examples[j];
                }
                this.information[await values[i].name()] = {
                    examples: e,
                    description: description,
                    string: string
                };
            }
        }
        await this.updateFieldList();
        this.field.addEventListener('change', () => {
            this.updateDataList();
        });
        await this.updateDataList();


    }

    updateFieldList() {
        for (const [key, value] of Object.entries(this.information)) {

            const option = document.createElement('option');
            option.value = key;
            option.text = value.description + ' ' + value.string;
            this.field.appendChild(option);
        }
    }

    async updateDataList() {
        const selectedField = this.field.value;
        const information = this.information[selectedField];
        if (information) {
            this.inputDataList.innerHTML = '';
            for (const example of information.examples) {
                const option = document.createElement('option');
                option.value = example;
                option.text = example;
                this.inputDataList.appendChild(option);
            }
            console.log("Updated data list for", selectedField, information.examples);
        }

    }

    async onSubmit(Calculator) {
        this.output.value = '';
        this.textContent = "executing..";
        //console.log("evaluating", this.input.value, "for", this.field.value);
        this.output.value = await Calculator.eval(
            this.input.value, this.field.value
        );
    }

}
----
====


== Solver

The same idea as my link:https://meeuw.org/flippo/flippo.html[very first applet]. Solving the '24 flippo game'.

Give the desired outcome number, and a few input numbers, and it will find the possible ways to get it using those input numbers.

This combines several aspects of this project:

- It uses 'rational numbers' to make all operations exact
- It uses the permutation group to permute all combinations of values
- It uses the Abstract Syntax Tree feature to combine values and operators
- It uses some features of the Field, e.g. to perform operators generically.
- It will currently use the field of `RationalNumbers` _or_ `GaussianRationals` if the input contains a complex number. I might add also suport for `RealField` (and for example also support the POW operator)

Cheerpj still sometimes behaves a bit erraticly, I think something may be wrong with default methods?

++++
<form id="solver" class="demo">
  <label for="solver_outcome">Desired outcome:</label>
  <input type="text"
         required="required"
         id="solver_outcome"  list="solver_outcome-examples"
         data-parser="parseOutcome"
         data-error-message="enter one (fractional) number"
         value="24"/>
  <datalist id="solver_outcome-examples">
     <option value="24">the original 24 game value</option>
     <option value="4 1/3">factions are allowed</option>
     <option value="41"></option>
     <option value="120">a nicer value for 5 input numbers</option>
   </datalist>
   <br />
  <label for="solver_input">Input numbers:</label>
  <input type="text" id="solver_input"
         list="solver_input-examples"
         required="required"
         placeholder="Enter a few numbers (probably no more than 5)"
          data-parser="parseInput"
          data-error-message="enter one or more (fractional) numbers"
         />
   <datalist id="solver_input-examples">
     <option value="8 8 3 3">a hard one to make 24 with</option>
     <option value="4 7 7 7 8" >a hard one to make 120 with</option>

   </datalist>
  <br />
  <output id="solver_output"  for="solver_result solver_numbers"> </output>
  <br />
  <button name="submit">go!</button>
</form>
++++

[%collapsible, title=java source code]
====
This is the source code for the above.
[source,java]
----
package org.meeuw.math.test;

import lombok.Getter;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Stream;

import org.meeuw.math.abstractalgebra.Ring;
import org.meeuw.math.abstractalgebra.RingElement;
import org.meeuw.math.abstractalgebra.complex.GaussianRationals;
import org.meeuw.math.abstractalgebra.permutations.PermutationGroup;
import org.meeuw.math.abstractalgebra.quaternions.Quaternions;
import org.meeuw.math.abstractalgebra.rationalnumbers.RationalNumbers;
import org.meeuw.math.arithmetic.ast.*;
import org.meeuw.math.exceptions.MathException;
import org.meeuw.math.exceptions.NotParsable;
import org.meeuw.math.operators.AlgebraicBinaryOperator;

import static org.meeuw.math.CollectionUtils.navigableSet;
import static org.meeuw.math.operators.BasicAlgebraicBinaryOperator.*;

/**
 * A tool to evaluate all possible expressions (of a certain number of rational numbers) (and check if it equals a certain value)
 */
public  class Solver<E extends RingElement<E>> {

    private static final NavigableSet<AlgebraicBinaryOperator> OPERATORS = navigableSet(
        ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION
    );

    private final AtomicLong tries = new AtomicLong();

    @Getter
    private final Ring<E> structure;

    public Solver(Ring<E> structure) {
        this.structure = structure;
    }

    @SafeVarargs
    public final Stream<Expression<E>> stream(E... set) {
        PermutationGroup permutations = PermutationGroup.ofDegree(set.length);

        return permutations.stream()
            .map(permutation -> permutation.permute(set))
            .map(List::of)
            .distinct()
            .flatMap(permuted ->
                AST.stream(
                    permuted,
                    OPERATORS
                )
            )
            .map( e -> e.canonize(structure))
            .distinct()
            .peek(e -> tries.getAndIncrement());
    }



    public Stream<EvaluatedExpression<E>> evaledStream(E... set) {
        return stream(set)
            .map(e -> {
                try {
                    E evaled = e.eval();
                    return new EvaluatedExpression<>(e, evaled);
                } catch (MathException ex) {
                    return null;
                }
            })
            .filter(Objects::nonNull);
    }

    /**
     *
     */
    public  static <E extends RingElement<E>> SolverResult solve(Ring<E> structure, String outcomeString, String inputStrings) {

        ParseResult<E> outcome = parseOutcome(structure, outcomeString);
        ParseResult<E[]> input = parseInput(structure, inputStrings);
        if (outcome.success() && input.success()) {
            return solve(structure, outcome.result(), input.result());
        } else {
            throw new NotParsable(outcome.error() + "/" + input.error());
        }
    }

    public  static <E extends RingElement<E>> SolverResult solve(Ring<E> structure, E outcome, E[] input) {

        Solver<E> solver = new Solver<>(structure);
        AtomicLong matches = new AtomicLong();
        return new SolverResult(solver.evaledStream(input)
            .filter(e ->
                e.result().eq(outcome)
            ).peek(e -> matches.getAndIncrement())
            .map(EvaluatedExpression::toString),
            solver.tries, matches, structure);
    }

    public static <F extends RingElement<F>> ParseResult<F> parseOutcome(Ring<F> field, String outcomeString) {
        String resultError = null;
        F result;
        try {
            result = field.fromString(outcomeString);
        } catch (NotParsable pe) {
            result = null;
            resultError = pe.getMessage();
        }
        return new ParseResult<F>(outcomeString, result, resultError);
    }
    public static <F extends RingElement<F>> ParseResult<F[]> parseInput(Ring<F> field, String inputStrings) {
        String inputError = null;

        String[] input = inputStrings.split("\\s+");
        F[] set = field.newArray(input.length);
        try {
            for (int i = 0; i < set.length; i++) {
                set[i] = field.fromString(input[i]);
            }
        } catch (NotParsable pe) {
            inputError = pe.getMessage();
        }
        return new ParseResult<>(inputStrings, set, inputError);
    }

    public static Ring<?> algebraicStructureFor(String outcomeString, String input) {
        if (outcomeString.matches(".*[jk].*") || input.matches(".*[jk].*")) {
            return Quaternions.of(RationalNumbers.INSTANCE);
        } else if (outcomeString.contains("i") || input.contains("i")) {
            return GaussianRationals.INSTANCE;
        } else {
            return RationalNumbers.INSTANCE;
        }
    }


    public record SolverResult(Stream<String> stream, AtomicLong tries, AtomicLong matches, Ring<?> field) {


    }

    public static void main(String[] integers) {
        if (integers.length < 3) {
            System.out.println();
            System.exit(1);
        }
        String resultString = integers[0];
        String inputStrings = String.join(" ", Arrays.copyOfRange(integers, 1, integers.length));

        Ring<?> field = algebraicStructureFor(resultString, inputStrings);
        SolverResult solverResult = Solver.solve(field, resultString, inputStrings);
        solverResult.stream().forEach(System.out::println);
        System.out.println("ready, found " + solverResult.matches().get() + ", tried " + solverResult.tries.get() + ", field " + solverResult.field().toString());
    }
}
----
====
[%collapsible, title=javascript]
====
This is the source code for the above.
[source,javascript]
----


    async onSubmit(Solver) {
        this.output.value += "using: " + await (this.model.field).toString();
        const solverResult = await Solver.solve(
            this.model.field, self.outcome.value, self.input.value);

        const stream = await solverResult.stream();
        const lines = await stream.toArray();
        for (let i = 0; i < lines.length; i++) {
            this.output.value += "\n" + await lines[i].toString();
        }
        const tries = await (await solverResult.tries()).get();
        const matches = await (await solverResult.matches()).get();
        this.output.value += `\nFound: ${matches}`;
        this.output.value += `\nTried: ${tries}`;
    }
}
----
====


== Dynamic date parsing

The `mihxil-time` module contain a 'dynamic date parser. I dusted this of from old link:mmbase.org[mmbase] code.

++++
<form id="dynamicdate" class="demo">
  <label for="dynamicdate_toparse">String to parse:</label> <input type="text" id="dynamicdate_toparse"  list="dynamicdate_toparse-examples" value="" />
   <datalist id="dynamicdate_toparse-examples">
    <option value="0"></option>
    <option value="10000"></option>
    <option value="-10000"></option>
    <option value="+1000"></option>
    <option value="1973-05-03"></option>
    <option value="2006-05-09"></option>
    <option value="-3-12-25"></option>
    <option value="2000-01-01 16:00"></option>
    <option value="TZUTC 2001-01-01 16:00"></option>
    <option value="today 12:34:56.789"></option>
    <option value="now"></option>
    <option value="today"></option>
    <option value="tomorrow"></option>
    <option value="now + 10 minute"></option>
    <option value="today + 5 day"></option>
    <option value="now this year"></option>
    <option value="next august"></option>
    <option value="today + 6 month next august"></option>
    <option value="tomonth"></option>
    <option value="borreltijd"></option>
    <option value="today + 5 dayish"></option>
    <option value="yesteryear"></option>
    <option value="mondayish"></option>
    <option value="duration + 5 minute"></option>
    <option value="duration + 100 year"></option>
    <option value="TZUTC today noon"></option>
    <option value="TZEurope/Amsterdam today noon"></option>
    <option value="TZUTC today"></option>
    <option value="TZEurope/Amsterdam today"></option>
    <option value="TZ UTC today noon"></option>
    <option value="TZ Europe/Amsterdam today noon"></option>
    <option value="TZ UTC today"></option>
    <option value="TZ Europe/Amsterdam today"></option>
    <option value="TZ Europe/Amsterdam -1000"></option>
    <option value="today 6 oclock"></option>
    <option value="today 23 oclock"></option>
    <option value="today 43 oclock"></option>
    <option value="tosecond"></option>
    <option value="tominute"></option>
    <option value="tohour"></option>
    <option value="today"></option>
    <option value="previous monday"></option>
    <option value="tomonth"></option>
    <option value="toyear"></option>
    <option value="tocentury"></option>
    <option value="tocentury_pedantic"></option>
    <option value="toera"></option>
    <option value="toweek"></option>
    <option value="now this second"></option>
    <option value="now this minute"></option>
    <option value="now this hour"></option>
    <option value="now this day"></option>
    <option value="today previous monday"></option>
    <option value="now this month"></option>
    <option value="now this year"></option>
    <option value="now this century"></option>
    <option value="now this era"></option>
    <option value="now - 15 year this century"></option>
    <option value="now - 20 year this century_pedantic"></option>
    <option value="today + 2 century"></option>
    <option value="toera - 1 minute"></option>
    <option value="this july"></option>
    <option value="previous july"></option>
    <option value="next july"></option>
    <option value="this sunday"></option>
    <option value="previous sunday"></option>
    <option value="next sunday"></option>
    <option value="2009-W01-01"></option>
    <option value="2009-W53-7"></option>
    <option value="2006-123"></option>
    <option value="2005-01-01 this monday"></option>
    <option value="next year"></option>
    <option value="&quot;spring&quot;"></option>
    <option value="next year &quot;spring&quot;"></option>
    <option value="&quot;easter sunday&quot;"></option>
   </datalist>
   <br />
  <output id="dynamicdate_output" for="dynamicdate_toparse"> </output>
  <br />
  <button name="submit">go!</button>
</form>
++++

[%collapsible, title=javascript]
====
This is the source code for the above.
[source,javascript]
----

async onSubmit(DynamicDateTime){
    try {
        const parser = await new DynamicDateTime();
        const parseResult = await parser.applyWithException(this.form.querySelector("#dynamicdate_toparse").value);
        this.output.value = await parseResult.toString();
    } catch (error) {
        console.log(error);
    }

}

----
====
