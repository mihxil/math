options {
    LOOKAHEAD = 3;
    STATIC = false;
    FORCE_LA_CHECK = true;
    IGNORE_CASE = true;
    CHOICE_AMBIGUITY_CHECK = 2;
    GENERATE_GENERICS = true;
    GENERATE_STRING_BUILDER	= true;
    JAVA_TEMPLATE_TYPE = "modern";
    UNICODE_INPUT = true;
}

PARSER_BEGIN(InfixParser)

package org.meeuw.math.arithmetic.ast.infix;

import java.util.function.Supplier;import org.meeuw.math.abstractalgebra.*;
import org.meeuw.math.arithmetic.ast.*;
import org.meeuw.math.operators.*;

public class InfixParser<E extends AlgebraicElement<E>> {

    private AlgebraicStructure<E> structure;

    public InfixParser(Provider provider, AlgebraicStructure<E> s) {
        this(provider);
        this.structure = s;
    }
    public InfixParser(String provider, AlgebraicStructure<E> s) throws ParseException {
        this(provider);
        this.structure = s;
    }

    public AlgebraicBinaryOperator getOperationBySymbol(Token string) {
        String token = string.image;
        if (token.equals("*")) {
            token = "⋅";
        }
        return structure.getOperationBySymbol(token).orElseThrow(
              new Supplier<IllegalArgumentException>() {
          public IllegalArgumentException get() {
             return   new IllegalArgumentException("No such operator " + string + "' in " + structure + " (" + structure.getSupportedOperators() + ")");
          }
        });
    }

      public AlgebraicUnaryOperator getUnaryOperationBySymbol(Token  string) {
        return structure.getUnaryOperationBySymbol(string.image).orElseThrow(
              new Supplier<IllegalArgumentException>() {
          public IllegalArgumentException get() {
             return   new IllegalArgumentException("No such operator " + string + "' in " + structure + " (" + structure.getSupportedUnaryOperators() + ")");
          }
        });
    }

    private Supplier<IllegalArgumentException> illegalArgument(String type, Token illegalValue) {
        return new Supplier<IllegalArgumentException>() {
          public IllegalArgumentException get() {
             return   new IllegalArgumentException("No such " + type + " '" + illegalValue.image + "' in " + structure);
          }
        };
    }
}


PARSER_END(InfixParser)

SKIP : {
    " " | "\t" | "\n" | "\r"
}

TOKEN : {
    < NUMBER: (["0"-"9"])+ ( "." (["0"-"9"])+ )? (["i"-"k"])? >
|   < QUOTED_STRING: "\"" (~["\""])* "\"" >
|   < PLUS: (["+", "-"]) >
|   < MULT: (["*", "/"]) >
|   < POW: "^" >
|   < LPAREN: "(" >
|   < RPAREN: ")" >
|   < FUNCTION: ( ["a"-"z"])+ >
|   < SYMBOLS: "𝜋" |  "𝜑"  >

}


Expression<E> parse() :
{
   Expression<E> expression;
}
 {
   expression = sum() <EOF>   // sum has lowes priority, so that goes first
  {return expression; }

}


Expression<E> sum() :
{
    Expression<E> left = null;
    Expression<E> right;
    Token  op;
}
{
    left = product()
     (
        op = <PLUS>
        right = product()
        {left = new BinaryOperation<>(getOperationBySymbol(op), left, right);}
     )*
    { return left; }
}

Expression<E> product() :
{
      Expression<E> left = null;
      Expression<E> right;
      Token  op;
}
{
    left = power()
     (
        op = <MULT>
        right = power()
        {left = new BinaryOperation<>(getOperationBySymbol(op), left, right);}
     )*
    { return left; }
}

Expression<E> power() :
{
      Expression<E> left = null;
      Expression<E> right;
      Token op;
}
{
    left = term()
     (
        op = <POW>
        right = term()
        {left = new BinaryOperation<>(getOperationBySymbol(op), left, right);}
     )*
    { return left; }
}

Value<E> number() : {
    Token sign  = null;
    Token t;
}
{
   ((
    (sign = <PLUS>)?
    t = <NUMBER>
    ) |
    (
      t = <QUOTED_STRING>
    )
    )
    {
       String numberString = (sign == null ? "" : sign.image) +
       (t.kind == QUOTED_STRING ? t.image.substring(1, t.image.length() - 1) : t.image);
       return new Value<>(structure.fromString(numberString));
    }
}

Expression<E> term() :
{ Expression<E> expr; }
{
  (
    expr = number()

 |  <LPAREN> expr = sum() <RPAREN>
|   expr = function()
| expr = constant()
)
   {return expr;}
}

UnaryOperation<E> function() :
{
      Token functionName;
      Expression<E> functionArgument;
}
{
    functionName = <FUNCTION>
    "(" functionArgument = sum() ")"

   {
     return new UnaryOperation<>(getUnaryOperationBySymbol(functionName), functionArgument);
   }
}

Value<E> constant() :
{
      Token constantName;
}
{
    ( constantName = <FUNCTION>
     | constantName = <SYMBOLS>
    )
   {
     return new Value<>(structure.getConstant(constantName.image).orElseThrow(illegalArgument("constant", constantName)));
   }
}
