options {
    LOOKAHEAD = 3;
    STATIC = false;
    FORCE_LA_CHECK = true;
    IGNORE_CASE = true;
    CHOICE_AMBIGUITY_CHECK = 2;
    GENERATE_GENERICS = true;
    GENERATE_STRING_BUILDER	= true;
    JAVA_TEMPLATE_TYPE = "modern";
    UNICODE_INPUT = true;
}

PARSER_BEGIN(InfixParser)

package org.meeuw.math.arithmetic.ast.infix;

import java.util.function.*;
import java.util.Optional;
import org.meeuw.math.abstractalgebra.*;
import org.meeuw.math.arithmetic.ast.*;
import org.meeuw.math.operators.*;

@SuppressWarnings("Convert2Lambda")
public class InfixParser<E extends AlgebraicElement<E>> {

    private AlgebraicStructure<E> structure;

    private BiFunction<String, String, Optional<E>> getConstant;


    public InfixParser(Provider provider, AlgebraicStructure<E> s, BiFunction<String, String, Optional<E>> getConstant) {
        this(provider);
        this.structure = s;
        this.getConstant = getConstant;
    }

    public InfixParser(String string, AlgebraicStructure<E> s, BiFunction<String, String, Optional<E>> getConstant) throws ParseException {
        this(string);
        this.structure = s;
        this.getConstant = getConstant;
    }

    AlgebraicBinaryOperator getOperationBySymbol(Token string) {
        String token = string.image;
        return structure.getOperationBySymbol(token).orElseThrow(
              new Supplier<IllegalArgumentException>() {
          public IllegalArgumentException get() {
             return   new IllegalArgumentException("No such operator '" + token + "' in " + structure + " (" + structure.getSupportedOperators() + ")");
          }
        });
    }

    AlgebraicUnaryOperator getUnaryOperationBySymbol(Token  string) {
        return structure.getUnaryOperationBySymbol(string.image).orElseThrow(
              new Supplier<IllegalArgumentException>() {
          public IllegalArgumentException get() {
             return   new IllegalArgumentException("No such unary operator '" + string + "' in " + structure + " (" + structure.getSupportedUnaryOperators() + ")");
          }
        });
    }

    AlgebraicUnaryOperator getUnaryOperationBySymbol(String placeHolder, Token  string) {
            return structure.getUnaryOperationBySymbol(placeHolder + string.image).orElseThrow(
                  new Supplier<IllegalArgumentException>() {
              public IllegalArgumentException get() {
                 return   new IllegalArgumentException("No such unary operator '" + string + "' in " + structure + " (" + structure.getSupportedUnaryOperators() + ")");
              }
            });
        }

    private Supplier<IllegalArgumentException> illegalArgument(String type, Token illegalValue) {
        return new Supplier<>() {
          public IllegalArgumentException get() {
             return   new IllegalArgumentException("No such " + type + " '" + illegalValue.image + "' in " + structure);
          }
        };
    }
}


PARSER_END(InfixParser)

SKIP : {
    " " | "\t" | "\n" | "\r"
}

TOKEN : {
    < NUMBER: (["0"-"9"])+ ( "." (["0"-"9"])+ )? (["i"-"k"])? >
|   < QUOTED_STRING: "\"" (~["\""])* "\"" >
|   < SIGN: (["+", "-"]) >
|   < MULT: (["*", "/", "â‹…", "\\", "%" ]) >
|   < POW: "^" >
|   < LPAREN: "(" >
|   < RPAREN: ")" >
|   < FUNCTION: (["a"-"z"]) (["a"-"z", "0"-"9"])* >
|   < UNARY_POSTFIX: ( "!" ) >
|   < SYMBOLS: "ðœ‹" |  "ðœ‘"  >

}


Expression<E> parse() :
{
   Expression<E> expression;
}
 {
   expression = sum() <EOF>   // sum has lower priority, so that goes first
  {return expression; }

}


Expression<E> sum() :
{
    Expression<E> left = null;
    Expression<E> right;
    Token  op;
}
{
    left = product()
     (
        op = <SIGN>
        right = product()
        {left = new BinaryOperation<>(getOperationBySymbol(op), left, right);}
     )*
    { return left; }
}

Expression<E> product() :
{
      Expression<E> left = null;
      Expression<E> right;
      Token  op;
}
{
    left = power()
     (
        op = <MULT>
        right = power()
        {left = new BinaryOperation<>(getOperationBySymbol(op), left, right);}
     )*
    { return left; }
}

Expression<E> power() :
{
      Expression<E> left = null;
      Expression<E> right;
      Token op;
}
{
    left = factor()
     (
        op = <POW>
        right = factor()
        {left = new BinaryOperation<>(getOperationBySymbol(op), left, right);}
     )*
    { return left; }
}

Expression<E> factor() :
{
    Expression<E> base = null;
    Token postfix;
}
{
    base = term()
    (
        postfix = <UNARY_POSTFIX>
        { base = new UnaryOperation<>(getUnaryOperationBySymbol("x", postfix), base); }
    )*
    { return base; }
}

Value<E> number() : {
    Token sign  = null;
    Token t;
}
{
   ((
    (sign = <SIGN>)?
    t = <NUMBER>
    ) |
    (
      t = <QUOTED_STRING>
    )
    )
    {
       String numberString = (sign == null ? "" : sign.image) +
       (t.kind == QUOTED_STRING ? t.image.substring(1, t.image.length() - 1) : t.image);
       return new Value<>(structure.fromString(numberString));
    }
}

Expression<E> term() :
{ Expression<E> expr; }
{
  (
    expr = number()

 |  <LPAREN> expr = sum() <RPAREN>
|   expr = function()
| expr = constant()
)
   {return expr;}
}

UnaryOperation<E> function() :
{
      Token functionName;
      Expression<E> functionArgument;
}
{
    functionName = <FUNCTION>
    "(" functionArgument = sum() ")"
   {
     return new UnaryOperation<>(getUnaryOperationBySymbol(functionName), functionArgument);
   }
}



Value<E> constant() :
{
      Token sign = null;
      Token constantName;
}
{
    (sign = <SIGN>)?
    ( constantName = <FUNCTION>
     | constantName = <SYMBOLS>
    )
   {
     return new Value<>(getConstant.apply(sign == null ? null : sign.image, constantName.image).orElseThrow(illegalArgument("constant", constantName)));
   }
}
