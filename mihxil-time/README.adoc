// DO NOT EDIT THIS FILE IT IS GENERATED!!
= time
:toc:

image:https://img.shields.io/maven-central/v/org.meeuw/mihxil-time.svg[Maven Central,link=https://search.maven.org/artifact/org.meeuw/mihxil-time]
image:https://www.javadoc.io/badge/org.meeuw/mihxil-time.svg?color=blue[javadoc,link=https://www.javadoc.io/doc/org.meeuw/mihxil-time]

This collects some utility related to time (actually to Durations and Instants). The main purpose is to provide a way to represent uncertain values of time, but it also provides some utilities for working with `Clock`.

== Uncertain `java.time` objects

This module provides things like `org.meeuw.time.UcertainInstant` and `org.meeuw.time.UncertainDuration', which are very similar to their `java.time` equivalents, but implement also `UncertainNumber`, so basically represents temporary objects _with an uncertaintiy_ in their value.

== Clocks

Because some uncertain values may be related to event rates, you may also need some things related to clocks. Especially, in test cases.

=== `TestClock`

A clock which must be manually 'ticked'. This  is mainly useful for testing purposes.

=== `UniqueClock`

A clock for which each call is guaranteed to result an Instant strictly after all previous calls. This can be used in tests, but also in production code, for example to ensure that events are always uniquely ordered.

== Dynamic date time parsing

Can be found in `DynamicDateTime`. E.g. parse things like 'tomorrow' to actual time instances. This is based on https://github.com/mmbase/mmbase/blob/MMBase-1_9/core/src/main/javacc/org/mmbase/util/dateparser/DateParser.jj[old MMBase code]. It is a https://javacc.org[javacc-grammar]. I modernized it to be fully based on `java.time` classes, and also incorporate the 'event searchers' I added to https://natty-parser.github.io[natty].

=== syntax

[NOTE]
====
This section is work in progress
====

The most basic idea is:
[source]
----
[<base time>] [modifications]*
----
So, it starts with specifying some absolute time, which can be dynamic (refer to the current clock).

If no <base time> is specified, that implies 'now'.

Like so (where the current time is february 20, 2020)
|===
| Input | Output | remarks

| now  | 2020-02-20T20:20+01:00[Europe/Amsterdam] |
| | 2020-02-20T20:20+01:00[Europe/Amsterdam] | 'now' is the default, so the empty string is valid too.
| today | 2020-02-20T00:00+01:00[Europe/Amsterdam]  | start with some rounded value
| tohour | 2020-02-20T20:00+01:00[Europe/Amsterdam]  | other unit than 'day' are possible too

| 1973-03-05T06:00 | 1973-03-05T06:00+01:00[Europe/Amsterdam] | just state it in ISO foramt
| 1973-03-05 | 1973-03-05T00:00+01:00[Europe/Amsterdam] | time is optional
|===

Then zero or more 'modifications' or 'offset' can be given. Most basically with + and -.

[options="header"]
|===
| Input | Output | remarks
| now + 5 minute | 2020-02-20T20:25+01:00[Europe/Amsterdam] |
| 2021-08-05T20:00 + 1 minute - 2 days | 2021-08-03T20:01+02:00[Europe/Amsterdam |
| next week | 2021-08-03T20:01+02:00[Europe/Amsterdam |
|===

There are also ways to set offsets which are not implicitly positive or negative. They just jump to some relevant time of some current period.

The offset can for example be something like 'this month', 'this day', or 'today', which basically arranges rounding

[options="header"]
|===
| Input | Output | remarks
| now this day | 2020-02-20T00:00+01:00[Europe/Amsterdam] |
| now tohour | 2020-02-20T20:00+01:00[Europe/Amsterdam] | 'to-' an alias for that too.
| 2025-08-30 teatime | 2025-08-30T16:00+02:00[Europe/Amsterdam]
| some other our indcation can be used too
|===

Finally, then entire thing can be post fixed and prefixed by an explicit timezone. The timezone defaults to `ZoneId#systemDefault`.

[options="header"]
|===
| Input | Output | remarks
| TZUTC today | 2025-11-23T00:00Z[UTC] |
|===


=== demo

Here is a (working) demo for this.

:leveloffset: 2


++++
<form id="dynamicdate" class="demo">
  <label for="dynamicdate_toparse">String to parse:</label> <input type="text" id="dynamicdate_toparse"  list="dynamicdate_toparse-examples" value="" />
   <datalist id="dynamicdate_toparse-examples">
    <option value="0"></option>
    <option value="10000"></option>
    <option value="-10000"></option>
    <option value="+1000"></option>
    <option value="1973-05-03"></option>
    <option value="2006-05-09"></option>
    <option value="-3-12-25"></option>
    <option value="2000-01-01 16:00"></option>
    <option value="TZUTC 2001-01-01 16:00"></option>
    <option value="today 12:34:56.789"></option>
    <option value="now"></option>
    <option value="today"></option>
    <option value="tomorrow"></option>
    <option value="now + 10 minute"></option>
    <option value="today + 5 day"></option>
    <option value="now this year"></option>
    <option value="next august"></option>
    <option value="today + 6 month next august"></option>
    <option value="tomonth"></option>
    <option value="borreltijd"></option>
    <option value="today + 5 dayish"></option>
    <option value="yesteryear"></option>
    <option value="mondayish"></option>
    <option value="duration + 5 minute"></option>
    <option value="duration + 100 year"></option>
    <option value="TZUTC today noon"></option>
    <option value="TZEurope/Amsterdam today noon"></option>
    <option value="TZUTC today"></option>
    <option value="TZEurope/Amsterdam today"></option>
    <option value="TZ UTC today noon"></option>
    <option value="TZ Europe/Amsterdam today noon"></option>
    <option value="TZ UTC today"></option>
    <option value="TZ Europe/Amsterdam today"></option>
    <option value="TZ Europe/Amsterdam -1000"></option>
    <option value="today 6 oclock"></option>
    <option value="today 23 oclock"></option>
    <option value="today 43 oclock"></option>
    <option value="tosecond"></option>
    <option value="tominute"></option>
    <option value="tohour"></option>
    <option value="today"></option>
    <option value="previous monday"></option>
    <option value="tomonth"></option>
    <option value="toyear"></option>
    <option value="tocentury"></option>
    <option value="tocentury_pedantic"></option>
    <option value="toera"></option>
    <option value="toweek"></option>
    <option value="now this second"></option>
    <option value="now this minute"></option>
    <option value="now this hour"></option>
    <option value="now this day"></option>
    <option value="today previous monday"></option>
    <option value="now this month"></option>
    <option value="now this year"></option>
    <option value="now this century"></option>
    <option value="now this era"></option>
    <option value="now - 15 year this century"></option>
    <option value="now - 20 year this century_pedantic"></option>
    <option value="today + 2 century"></option>
    <option value="toera - 1 minute"></option>
    <option value="this july"></option>
    <option value="previous july"></option>
    <option value="next july"></option>
    <option value="this sunday"></option>
    <option value="previous sunday"></option>
    <option value="next sunday"></option>
    <option value="2009-W01-01"></option>
    <option value="2009-W53-7"></option>
    <option value="2006-123"></option>
    <option value="2005-01-01 this monday"></option>
    <option value="next year"></option>
    <option value="&quot;spring&quot;"></option>
    <option value="next 'spring'"></option>
    <option value="2030-01-01 this 'spring'"></option>
    <option value="&quot;easter sunday&quot;"></option>
   </datalist>
   <br />
  <output id="dynamicdate_output" for="dynamicdate_toparse"> </output>
  <br />
  <button name="submit" class="cheerpjprogress">go!</button>
</form>
++++

[%collapsible, title=javascript]
====
This is the source code for the above.
[source,javascript]
----
async onSubmit(DynamicDateTime){
    try {
        const parser = await new DynamicDateTime();
        const parseResult = await parser.applyWithException(
            this.form.querySelector("#dynamicdate_toparse").value
        );
        this.output.value = await parseResult.toString();
    } catch (error) {
        console.log(error);
        this.output.value = await (await error.getMessage()).toString();
    }
}
----
====


:leveloffset!:

It is a bit more elaborated link:https://mihxil.github.io/math/DEMO.html#demo_dynamicdate[here]

=== Comparison to MMBase

The parser in MMBase was actually implemented as an extension of `java.util.Date` itself (`org.mmbase.util.DynamicDate`), and was in that aspect simpler. But it was not a very good citizen because of that, because the actually value of the date could be 'dynamic', and sometimes that required some explicit conversion to a normal `java.util.Date` object. Turns out that date object can't be extended very well.

So, this idea was dropped. The parser was taken as is but, it was converted to parse to `java.time.ZonedDateTime` instead of `java.util.Date`, also a wrapper class was added `DynamicDateTime`, which can contain a bit of configuration for the parsing (like the `Clock` to use).

Also, inspired by natty, the 'event searchers' are added so the parser can also support holidays and other events like 'next spring'.



=== Comparison to natty

I always thought that for the use cases I saw natty was not a very good fit, and my own, old, mmbase utility was nicer.

- natty parses entire sentences, and tries to find all date-like strings in it, therefore, also it returns a complicated DateGroup object as a parse result
- DynamicDateTime always parses to one ZonedDateTime, or gives an exeption

The idea is that this can be used in configurations or requests that are dependent on the current time. E.g., 'give me all objects created between 2 weeks ago' and 'now'.  Using the parser, it can support this for you. It'll parse ISO dates, but also 'now' and similar things.


TODO: add more documentation
